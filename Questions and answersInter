Important topics and Explanation

JDK- Java developemt kit 
it is use to develop and run java application, JDK is platform independent

JDK=JRE+developement tools

JRE- Java Runtime Envrionment 
is used in the client machine just to run- 

JRE=JVM+library classes

JVM is a virtul machine which is a interpretor and it is responsible for line by line execution.JVM converts the byte code into machine level language
 JVM is also platform dependent and provides core java functions like memory management, garbage collection, security etc.
 WE need to have different jvm for different operating system

 1-No, declaring the constructor as final is not possible.

 *Garbage Collection

 Garbage collector is best example of Daemon thread as it is always running in background.
 Finilization:Just before destroying an object, Garbage Collector calls finalize() method on the object to perform cleanup activities. Once finalize() method completes, Garbage Collector destroys that object.

Stack is used to method execution, Heap is used for storing objects

Static members,private,constructors cannot be over rided and access specifiers can be changed but cannot be reduced

String s1="thejas"
String s2="thejas"// String pool does not allow duplicated objects so only one object gets created and so s1==s2

but String s3=new String("thejas")// Object is created in heap so s1!=s3

		** 				private		     default      		protected	public
		Class			No					Yes				No		Yes
		Nested Class	Yes					Yes				Yes		Yes
		Constructor		Yes					Yes				Yes		Yes
		Method			Yes					Yes				Yes		Yes
		Field			Yes					Yes				Yes		Yes

		A class can only be default,public and  Inner class can be privet,default,proetcted,public

		For overriding the return type does not matter only methodname and argumentlist matter

 variables declared using static final needs to be initialized
 variables decalred using final keyword can only be initialized in a constructor
 final methods are inherited but are not overridden
 final keyword cannot be used to constructor because constructors are not inherited
 We cannot create a final interface
 we cannot use abstract and static keywords together
 Serializable is a marker interface


**Creating custom Annotation
1.WE need to use @interface annotation 

eg @interface smartPhone{
	
	String os();
	int version();
}

we can now use @smartPhone(os="symbian",version="1") as annotation

	If the annotation does not have any value then it is called markerAnnotation
	If it has one value then single value annotation

	Using ReflectionApi we can get the value or features of the object



Cohesion refers to the level of a component which performs a single well-defined task.

In java we have call by value there is no call by reference in java because we donot have pointers
In java whatever changes we make it will be only applicable inside the method

Call by value means calling the function with parameter as value

call by reference means calling the function with paramater as reference

Association
	It is a relation between 2 independent classes establised through their objects

	Composition and Aggregation are the 2 forms of Association.

	Aggregation is a has a relationship

		It is a unidirectional association eg department has students but vicecersa is not possible

		In Aggregation, both the entries can survive individually which means ending one entity will not effect the other entity

Composition is a restricted form of Aggregation in which two entities are highly dependent on each other.
It represent parts of relationship

Composition is a strong Association whereas Aggregation is a weak Association.


Volatile is used to solve the visiblity problem
Whenever we use volatile for a variable , and we change the value the value will be changed in the main memory and then it will be refreshed in all the threads in which this value is used

For Synchronization we use Atmoic Variable
eg value++
AtomicInteger value=new AtomicINteger(1);
		value.incrementAndGet();

Design Patterns
1.Factory Design Patterns

	It is a design pattern where we are providing the interface to create a object and the subclass has to pass the type and depending on the type we are creating the object

	The Factory Method Pattern is also known as Virtual Constructor.

									class GetPlanFactory{  
			      
			   //use getPlan method to get object of type Plan   
			       public Plan getPlan(String planType){  
			            if(planType == null){  
			             return null;  
			            }  
			          if(planType.equalsIgnoreCase("DOMESTICPLAN")) {  
			                 return new DomesticPlan();  
			               }   
			           else if(planType.equalsIgnoreCase("COMMERCIALPLAN")){  
			                return new CommercialPlan();  
			            }   
			          else if(planType.equalsIgnoreCase("INSTITUTIONALPLAN")) {  
			                return new InstitutionalPlan();  
			          }  
			      return null;  
			   }  



2.Abstract Factory Pattern
		define an interface or abstract class for creating families of related (or dependent) objects but without specifying their concrete sub-classes

		example for all the baks we create a bankFctory Interface and for all the type of loean we create another INterface 

								class FactoryCreator {  
					     public static AbstractFactory getFactory(String choice){  
					      if(choice.equalsIgnoreCase("Bank")){  
					         return new BankFactory();  
					      } else if(choice.equalsIgnoreCase("Loan")){  
					         return new LoanFactory();  
					      }  
					      return null;  
					   }  
					}

3.ProtoType Design Pattern

	cloning of an existing object instead of creating new one and can also be customized as per the requirement.

		EmployeeRecord e1=new EmployeeRecord(eid,ename,edesignation,esalary,eaddress);  
          
        e1.showRecord();  
        System.out.println("\n");  
        EmployeeRecord e2=(EmployeeRecord) e1.getClone();  //IN get clone we are creating a object
        e2.showRecord();  

4.Builder Design Pattern
construct a complex object from simple objects using step-by-step approach

Create a tank Interface
create a fuel Interface

create a car interfcae which extends both tank and fuel

create a implementation nanocar extending car Interface


5.Adopter Design pattern: It is a structural design pattern where 2 unrelated interfaces can work together and the object which joins these 2 are called structural DesignPattern

6.Brdige Design Pattern
It is a structural Design Pattern where we seperate the abstraction hierarcy and implementation hieracy into 2 different layers so that chaneg in one layer will not effect the other layer

7.Facade DEsign patter is a patter where the complexities of the systme is hidden and the client is provided with the interface to access the system

8.Flyweight Design Pattern
In this design pattern reuseing the already ceated objects and resuing them and create new object when no match is found

9Chain of Responsibility
A request can be handled by a chain of objects , The request is not coupled to a single object rather than a chain
eg catchblock



Questions and answers

Difference between web server and application server

	Web Server is mostly designed to serve static content, though most Web Servers have plugins to support scripting languages like Perl, PHP, ASP, JSP etc. through which these servers can generate dynamic HTTP content.

	Most of the application servers have Web Server as integral part of them, that means App Server can do whatever Web Server is capable of. Additionally App Server have components and features to support Application level services such as Connection Pooling, Object Pooling, Transaction Support, Messaging services etc.
	
	As web servers are well suited for static content and app servers for dynamic content, most of the production environments have web server acting as reverse proxy to app server. That means while servicing a page request, static contents (such as images/Static HTML) are served by web server that interprets the request. Using some kind of filtering technique (mostly extension of requested resource) web server identifies dynamic content request and transparently forwards to app server
	Example of such configuration is Apache Tomcat HTTP Server and Oracle (formerly BEA) WebLogic Server. Apache Tomcat HTTP Server is Web Server and Oracle WebLogic is Application Server.

What is a servlet
Servlet stands for Server Component
resides on server and run on server and output will be on the client page
Servlets are used to create a dynamic contents.



SpringBootApplication.run(Currentclassname.class,args);
The return type of above call is ConfigurableApplicationContext context
we can do context.getbean(classname);- This is not used in practical but we can acess 


@Component - Using this annotation on top of a class  will create a singleton object for this class in spring container.Spring will create by itself


@Scope(value="prototype")- using this annotation along with @component will remove the singleton behaviour, The particular classes object ie bean inside spring container will only be created if we try to create it.

@Autowire is used to connect the dependent objects- This is used while using the class. If we donot use this annotaion then we will get null pointer exception when we try to access the class or its methods

We can change the name of the object created in the spring container, ie by using @Component("lap1")
Now in spring container the name of object created will be lap1

To use a class by its name we have to use 
@Qualifier annotation 
ie @Qualifier("lap1")
Laptop laptop

By default @Autowire searches by type
@Qualifier searches by name;

Springs IOC container is reposible for Instantiating,Configuring and managing the dependencies between the objects
There are 2 type of IOC Containers
1.BeanFactory Interface- Usually used for smaller applications(org.springframework.beans.factory.BeanFactory).
Since these are interface we need to initialize it with its implementation
ie for beanFactory
Resource resource=new ClassPathResource("applicationContext.xml");  
BeanFactory factory=new XmlBeanFactory(resource); 
HelloWorld obj = (HelloWorld) factory.getBean("helloWorld");    
      obj.getMessage();    
We can have only one configuration file
Usually, the implementations use lazy loading, which means that Beans are only instantiating when we directly calling them through the getBean() method.

2.ApplocationContext Interface- ApplicationContext is a built of top of BeanFactory.For larger enterpirse applications we have to use ApplicatioContext (org.springframework.context.ApplicationContext).
We can have multiple configuration files
Uses eager loading, so every bean instantiate after the ApplicationContext started up.

ApplicationContext context =   
    new ClassPathXmlApplicationContext("applicationContext.xml"); applicationContext.xml- File name where we have define the file name


    <import> tag is used to import bean definitions from other files
    eg:
    <beans>

    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>

</beans>
All location paths are considered relative to the definition file doing the importing, so services.xml in this case must be in the same directory or classpath location as the file doing the importing


Bean life cycle in Spring Bean Factory Container
		1.Bean Initialization
		2.Bean properties will be loaded and using dependency injection they will be wired
		3.WE will call the BeanNameAwares.setBeanName() and set the beanName
		4.We will call the BeanFactoryAwares.setBeanFactory() and set the bean factory
		5.WE will load the applicationcontext using ApplicationContextAwares
		5.If there is any preprocessInitialization requred that isdone
		6.Init meyhod get called specified for the bean will be called
		5If there is any post processor initilization is required that wuill be done
		6.Bean is ready to use
		7.After usage the container is shutdown
		8.destory method is called 


1.For static factory method

	When defining a bean which is to be created using a static factory method, along with the class attribute which specifies the class containing the static factory method, another attribute named factory-method is needed to specify the name of the factory method itself. Spring expects to be able to call this method (with an optional list of arguments as described later) and get back a live object, which from that point on is treated as if it had been created normally via a constructor. One use for such a bean definition is to call static factories in legacy code.

	The following example shows a bean definition which specifies that the bean is to be created by calling a factory-method. Note that the definition does not specify the type (class) of the returned object, only the class containing the factory method. In this example, the createInstance() method must be a static method.

Example

<bean id="exampleBean"
      class="examples.ExampleBean2"
      factory-method="createInstance"/>


2.For non static factory method

	Instantiation using an instance factory method is where a non-static method of an existing bean from the container is invoked to create a new bean. To use this mechanism, the 'class' attribute must be left empty, and the 'factory-bean' attribute must specify the name of a bean in the current (or parent/ancestor) container that contains the instance method that is to be invoked to create the object. The name of the factory method itself must be set using the 'factory-method' attribute.

Example

<!-- the factory bean, which contains a method called createInstance() -->
<bean id="serviceLocator" class="com.foo.DefaultServiceLocator">
  <!-- inject any dependencies required by this locator bean -->
</bean>

<!-- the bean to be created via the factory bean -->
<bean id="exampleBean"
      factory-bean="serviceLocator"
      factory-method="createInstance"/>


We can use another name to a bean using the alias tag

<alias name="fromName" alias="toName"/>

In this case, a bean in the same container which is named 'fromName', may also after the use of this alias definition, be referred to as 'toName'.


As a concrete example, consider the case where component A defines a DataSource bean called componentA-dataSource, in its XML fragment. Component B would however like to refer to the DataSource as componentB-dataSource in its XML fragment. And the main application, MyApp, defines its own XML fragment and assembles the final application context from all three fragments, and would like to refer to the DataSource as myApp-dataSource. This scenario can be easily handled by adding to the MyApp XML fragment the following standalone aliases:

<alias name="componentA-dataSource" alias="componentB-dataSource"/>
<alias name="componentA-dataSource" alias="myApp-dataSource" />
Now each component and the main application can refer to the dataSource via a name that is unique and guaranteed not to clash with any other definition (effectively there is a namespace), yet they refer to the same bean.


Constructor Injection

package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        // ...
    }
}

<beans>
    <bean name="foo" class="x.y.Foo">
        <constructor-arg>
            <bean class="x.y.Bar"/>
        </constructor-arg>
        <constructor-arg>
            <bean class="x.y.Baz"/>
        </constructor-arg>
    </bean>
</beans>

If there is ambiguity in the type, then use
<bean id="exampleBean" class="examples.ExampleBean">
  <constructor-arg type="int" value="7500000"/>
  <constructor-arg type="java.lang.String" value="42"/>
</bean>


We can also use index

<bean id="exampleBean" class="examples.ExampleBean">
  <constructor-arg index="0" value="7500000"/>
  <constructor-arg index="1" value="42"/>
</bean>

** Setter Injection vs Constructor Injection
	Partial dependency: can be injected using setter injection but it is not possible by constructor. ... Overriding: Setter injection overrides the constructor injection. If we use both constructor and setter injection, IOC container will use the setter injection. Changes: We can easily change the value by setter injection

Different ways of configuring the spring application
Configuration definition and bean definition are two different things. There are three ways to define configuration, available in Spring 4 by default:

xml-based configuration, when you describe configuration in xml file;
java-based configuration, when configuration is Java class, marked with specific annotations;
groovy-based configuration, when configuration is file with Groovy code;

And there are two ways to add bean definition into application:

1.Configuration inside bean definition, when you add beans manually by declaration right in configuration.

In this case definition will be based on configuration type. For xml-config it will be <bean/> tag, for java-based config - method with @Bean annotation 

2.Annotation based bean definition, when you mark bean classes with specific annotations (like @Component, @Service, @Controller etc). This type of config uses classpath scanning.

In this case you have to specify directive for scanning classpath. For xml-config it will be <context:component-scan base-package="..."/>, for java-config -@Configuration and  @ComponentScan annotation, 

Also If we want to to use anotation and spring xml then use
<context:annotation-config/>

1.	Context:component-scan (from spring2.5 version)

This element in the spring configuration file would eliminate the need for declaring all the beans in the XML files,also there is no need to update the xml file if we are adding the new beans. Look at the below declaration in your spring configuration file.


<context:component-scan base-package="org.controller"/>

The above declaration in the spring application configuration file would scan the classes inside the specified package and create the beans instance. Note that it could create beans only if that class is annotated with correct annotations. The following are the annotations scanned by this element:

@Component
@Repository
@Service
@Controller
One advantage of this element is that it also resolve @Autowired and @Qualifier annotations. Therefore if you declare <context:component-scan>, is not necessary anymore declare <context:annotation-config> too.

2. mvc:annotation-driven

If you dont include mvc:annotation-driven also your MVC application would work if you have used the context:component-scan for creating the beans or defined the beans in your XML file. Also it supports @NumberFormat,and we can also use @RestContoller in the place of @Controller 

@RestController=@Controller+@ResponseBody

When you use the @ResponseBody annotation on a method, Spring converts the return value and writes it to the http response automatically. Each method in the Controller class must be annotated with @ResponseBody.

3. context:annotation-config
This is used to activate annotation in beans already registered in application context.That means it will resolve @Autowired and @Qualifier annotations for the beans which are already created and stored in the spring container.

**	The <context:annotation-config /> only works on beans registered within the application context. Because I removed the XML configuration for the three beans there is no bean created and <context:annotation-config /> has no "targets" to work on.

context:component-scan can also do the same job, but context:component-scan will also scan the packages for registering the beans to application context. context:annotation-config will not search for the beans registration, this will only activate the already registered beans in the context.

	**  <context:annotation-config /> can be omitted if <context:component-scan> is specified but Spring takes care of running them only once.
So bottom line If we are using <context:component-scan> then we do not have to use <context:annotation-config>
In orion we use <context:component-scan> and <context:annotation-driven>


**	can we have multiple names for one bean definition
Yes we can have multiple name for one bean , but there should be only one id for a bean deifinition and the names used for bean should be unique

eg:- <bean id="petrolBean" name="shimba,mamu,radhe" class="com.marvel.java.Petrol">
	<property name="price" value="10"></property></bean>
	<bean id="petrolBean1" name="halva" class="com.marvel.java.Petrol">
	<property name="price" value="11"></property></bean> 

**	<context-param> is used to initialize something for the whole application
<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/applicationContext.xml</param-value>
	</context-param>
**	<init-param> will be used if you want to initialize some parameter for a particular servlet. When request come to servlet first its init method will be called then doGet/doPost
<servlet>
		<servlet-name>mvc-dispatcher</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:/META-INF/spring/applicationContext-servlet.xml</param-value>
		</init-param>

		<load-on-startup>1</load-on-startup>
	</servlet>


**	@Component – generic and can be used across application.
**	@Service – annotate classes at service layer level.
**	@Controller – annotate classes at presentation layers level, mainly used in Spring MVC.
**	@Repository – annotate classes at persistence layer, which will act as database repository.

** @Component vs @Bean

		@Component is used for component scanning and automatic wiring


		When should you use @Bean?

		Sometimes automatic configuration is not an option. When? Let's imagine that you want to wire components from 3rd-party libraries (you don't have the source code so you can't annotate its classes with @Component), so automatic configuration is not possible.

		The @Bean annotation returns an object that spring should register as bean in application context. The body of the method bears the logic responsible for creating the instance.

		@Bean is used above the method and @Component is used in the class


**	 @Autwired vs @Resource
			1.@Autowired is a spring annotation and @Resource is specified by JSR-250 ie java annotation.
			2.@Autowired + @Qualifier will work only with spring DI, if you want to use some other DI in future @Resource is good option


		JSRs are Java Specification Requests, basically change requests for the Java language, libraries and other components.
		It's all part of the Java Community Process, whereby interested parties can put forward their ideas for enhancements and (hopefully) have them taken up and acted upon


	**	Dispacther Servlet (it extends HttpServlet )
	DispatcherServlet acts as front controller  which receives the request and delegates in to the other component. The DispatcherServlet  provides a single entry point for a client request to Spring MVC web application and forwards request to Spring MVC controllers for processing.

	The DispatcherServlet uses HandlerMapping implementations -  to route incoming requests to handler objects. By default, it uses BeanNameUrlHandlerMapping and DefaultAnnotationHandlerMapping, which is driven by @RequestMapping annotation.
	DispatcherServlet scanes the class path.

Read more: https://javarevisited.blogspot.com/2017/09/dispatcherservlet-of-spring-mvc-10-points-to-remember.html#ixzz5vmyB0kT8

	 It is inherited from javax.servlet.http.HttpServlet, it is typically configured in the web.xml file.

	A web application can define any number of DispatcherServlet instances. Each servlet will operate in its own namespace, loading its own application context with mappings, handlers, etc.In most cases, applications have only single DispatcherServlet with the context-root URL(/), that is, all requests coming to that domain will be handled by it.

DispatcherServlet uses Spring configuration classes to discover the delegate components it needs for request mapping, view resolution, exception handling etc.

A Front Controller is a common pattern in web application and used to receive request and delegate to other components in the application for actual processing. 
eg:-
<servlet>
		<servlet-name>mvc-dispatcher</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:/META-INF/spring/applicationContext-servlet.xml</param-value>
		</init-param>

		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>mvc-dispatcher</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>
	In the above xml configuration we define a Dispatched servelt and <init-param> is used to initialize the applicationContext-servlet.xml file which has <compoment scan> for the defined base packages

	ie <context:component-scan base-package="com.infomatics.orion.web" />
	and Under servlet-mapping we give a url patter so that al the url will go through dispatecher servlet which is the front controller of spring application
	

	
** What are Servlet Filters?
	Servlet filters are, in general, a Java WebApp concept. You can have servlet filters in any webapp, whether or not you use Spring framework in your application.

	These filters can intercept requests before they reach the target servlet. You can implement common functionality, like authorization, in servlet filters. Once implemented, you can configure the filter in your web.xml to be applied to a specific servlet, specific request url patterns or all url patterns.

** Where servlet filters are used?
	Modern web-apps can have dozens of such filters. Things like authorization, caching, ORM session management, and dependency injection are often implemented with the aid of servlet filter. All of these filters need to be registered in web.xml.

** Instantiating Servlet Filters - without Spring Framework
	Your servlet container creates instances of Filters declared in web.xml and calls them at appropriate times (i.e., when servicing servlet requests). Now if you are like most of the Dependency Injection (DI) fans, you would likely say that creation of instances is what my DI framework (Spring) does better. Can't I get my servlet filters created with Spring so they are amenable to all DI goodness?

	DelegatingFilterProxy, so that Spring creates your filter instances,This is where DelegatingFilterProxy steps in.

 	DelegatingFilterProxy is an impelmentation of the javax.servlet.Filter interface provided by Spring Framework.

  	Once you configure DelegatingFilterProxy in web.xml, you can declare the actual beans that do the filtering in your spring configuration. This way, Spring creates the instances of beans that do the actual filtering, and you can use DI to configure these beans.

	Note that you need only a single DelegatingFilterProxy declaration in web.xml but you can have several filtering beans chained together in your application context.


**Spring security

	Spring security is based on servlet filters.

	Servlet filters are the implementation of javax.servlet filter interface which you create and register in web.xml

	once we write that in web.xml the servlet container will read those and will creat a filter
	Servlet container is a part of web server eg for apache tomcat , 
		apache is web server and tomcat is the servlet container.

	Servlet contanier is responsible for managing the life cycle of the servlet.
	
	DelegatingFilterProxy is also a implementation of javax.servlet interface provided by spring framework
	Delegating filterProxy is a bridge between servletcontainer and applicationContext

Authentication 
	means telling who am I ie by proving d the userId and Password and this type of authentication is called KNowledge Based 	Authentication

	There is also posession Based Authentication- T A text message comes to a thing which is posessed by the actual user



	MultiFactor Authentication = Knowledge+Posession

Authorization 
	Can this user do this

Principal
	In spring security contet it is the current Logged in user
	ONce you authenticate , the application establishes the principal, this is the reason we only login to application once and the principal will be stored

Authority means the permission given to the user to access something, Role based


Spring security default behaviour

1.Add Mandatory Authentication for all urs
2.Adds a login Form
3.Handles login error


Spring security features
1.Login and Logout functionality
2.Allow or block users from acessing the url's
3.Role access


*OAuth is user for intra app authorization
*Tokens can be used to micro service authorization
*method leve security


**	For login this is what we do

	<beans:bean id="restUsernamePasswordAuthenticationFilter"
		class="com.infomatics.orion.web.security.RestUsernamePasswordAuthenticationFilter">
		<beans:property name="authenticationDetailsSource"  ref="customAuthenticationDetailsSource" />
		<beans:property name="filterProcessesUrl" value="/login"/>
 		<beans:property name="authenticationManager" ref="authenticationManager" />
		<beans:property name="authenticationSuccessHandler" ref="restLoginSuccessHandler" />
		<beans:property name="authenticationFailureHandler" ref="restAuthenticationFailureHandler" />
	</beans:bean>

	<authentication-manager alias="authenticationManager">
		<authentication-provider user-service-ref="userDetailsService" />
	</authentication-manager>

	In the above xml mapping RestUsernamePasswordAuthenticationFilter is a implementation of UsernamePasswordAuthenticationFilter.

** UsernamePasswordAuthenticationFilter-https://howtodoinjava.com/spring-security/login-form-based-spring-3-security-example/



RestUserNameAuthenticationFilter is a implementation of UsernamePasswordAuthenticationFilter  and we are configuring the authication manager which will authenticate the user by his name ( it has only one mthod loadbyUserName()) and then we set the roles for that user 




** Cors- Cross Origin Resource Sharing 
	This cross-origin sharing standard is used to enable cross-site HTTP requests.

	Also, you can add information to instruct browser to allow only certain HTTP methods (GET/PUT/POST/DELETE etc) on those domain URLs.

** Response Headers of CorsFilter
		1.Access-Control-Allow-Origin:specifies the authorized domains to make cross-domain request. Use “*” as value if there is no restrictions.
		2.Access-Control-Allow-Credentials : specifies if cross-domain requests can have authorization credentials or not.
		Access-Control-Allow-Methods : indicates the methods allowed when accessing the resource.

	 response.addHeader("Access-Control-Allow-Origin", "http://127.0.0.1:9000");
		 response.addHeader("Access-Control-Allow-Credentials", "true");

		 In Orion CorsFilter extends OncePerRequestFilter
		
   ** OncePerRequestFilter makes sure of it that this authentication process happens only once



**Microservices

	They are independent spring boot applications which run to achive a task

	Using RestTemplate we can make a api call to another spring boot in order to achieve micro services.
	In futhure RestTemplate will be depricated and we have to use webclient which is from Reactive web.

	RestTemplate is thread safe
	RestTemplate restTemplate = new RestTemplate();
	Movie movie=restTemplate.getForObject("http://localhost:8081/movies"+movieId,Movies.class);

	WebClient.Builder builder=WebClient.builder();
	Movie movie=builder.build().get().uri("http://localhost:8081/movies"+movieId).retrieve().bodyToMono(Movie.class).block();

	bodyToMono is like a promise , You will not get it now but u have to wait. It is a Reactive web concept.

	we use block() because we are blocking the execution until the value is received.

	For post request use post() 

	** To change the port number if tomcat i spring boot 
	go to application.properties of ser/resource folder and type server.port=8081

** Spring core module

		Difference between spring mvc and spring core

		1.Spring core
			The Core is the Ioc container is reposible for Instantiating,Configuring and managing the dependencies between the objects.
			It give the features like dependency Injection and Inversion of Control.

			The context module present in the spring core will make the object or beans created in the container available for our use.


		2.Spring web- Spring we consists of servlets
					Spring web has mvc framework,
					It provides multipart file Upload functionality.


		3.Data Access/Integration- Has JDBS and ORM -eg Hibernate.

		4.Spring AOP- Aspect Oriented Programming

		5.Spring Instrumentation

		6.Spring test-The Test module contains the Test Framework that supports testing Spring components using JUnit or TestNG

**Mongodb Configuration in applicationContext-dao.xml file

<mongo:mongo-client id="mongoDB" host="${mongo.host}"
		port="${mongo.port}" />
	<mongo:db-factory id="mongoDbFactory" dbname="${mongo.dbname}"
		mongo-ref="mongoDB" />
	<mongo:mapping-converter id="converter" />
	<bean name="gridFsTemplate"
		class="org.springframework.data.mongodb.gridfs.GridFsTemplate">
		<constructor-arg ref="mongoDbFactory" />
		<constructor-arg ref="converter" />
	</bean>

and we can perform curd operations using MongoRepository creating a interface that extends MongoRepository

** Configuring datasource 

In Tomcat context.xml
<Resource auth="Container" driverClassName="com.mysql.jdbc.Driver" maxActive="50" maxIdle="30" maxWait="10000" 
name="jdbc/orionDataSource" password="orion123" type="javax.sql.DataSource" url="jdbc:mysql://localhost:3306/orion_db" username="root"/>

And in applicationContext.xml of orion_dao add

<jee:jndi-lookup id="dataSource" jndi-name="jdbc/orionDataSource"
		resource-ref="true" lookup-on-startup="true" />


For using entityManager,WE had 
<bean
		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"
		id="entityManagerFactory">
		<property name="dataSource" ref="dataSource" />
	</bean>

<tx:annotation-driven transaction-manager="transactionManager" />

Hence using
@PersistanceContext
EntityManager entityManager in BaseDao
we where able to execute queries

eg:
@Override
	public List<Backofficeemployee> getActiveBackofficeemployee() {
		String activeBackofficeemployee = "SELECT boe FROM Backofficeemployee as boe where boe.boeallowLogin = true and boe.boeuserType = 1";
		TypedQuery<Backofficeemployee> q1 = entityManager.createQuery(activeBackofficeemployee,
				Backofficeemployee.class);

		return q1.getResultList();
	}

**	Design Pattern

	Proxy Design Pattern - Proxy means 'on behalf of' or 'representing'
	Proxy is a object used by the client to access the real Object 
	This is mainly done for security reasons
	eg: 1.Role based Access
		2.Proxy server are used to check block certain sites in companies.
		3. @Transactional also creates Proxy object of Transaction

	Type Of Proxy
	1.Remote Proxy
	2.Virtual Proxy


**	@Transactional
	Spring will create a transactionInterceptor which will invoke the actual function like begin transaction,When the call ends it will invoke the commit or role back of the actual bean.

 	Spring wraps your bean in the proxy, your bean has no knowledge of it. Only calls from "outside" your bean go through the proxy.
	We are using in service layer on top of each method.
	Spring will create a wrapper method and dat method will begina and commit the transaction

**Light weight process vs Heavyweight process

	Light weight process will have multiple thread  sharing the same address space.
	
	Heavy weight Process- There will be different process created to work parally and each process has its own address space.

**Difference between Thread and Process

	A Process is a OS level task or service 
	A thread runs inside a process, usually process have their own address space where as threads use shared address space


Threads
Threads is a unit of a process
They are used for parallel execution and very java program creates at least one thread [ main() thread ].

t1.join() method will make other threads to stops until the current thread completes the execution.
isAlive() is used to check whether a thread is alive or not. after join method isAlive will return false.
t1.getPriority() will give the priority of thread, the raneg of priority ranges from 1 to 10.
We can also use inbuilt constants of thread for fixing priority
	eg t1.setPriority(Thread.MIN_PRIORITY);//this is bulit in constant
t1.setName("thejas")- will set the name of thread as thejas

Thread t2=new Thread(()->{ 
			 for(int i=0;i<=5;i++){
				 System.out.println("Apple of i"+i);
			 }
		});
		t2.start();

	adding "synchronized" will make a block or method thread safe, multiple threadsa cannot acces the same resource at a time

	t1.sleep(100) vs t1.wait()

	wait() method releases the lock   -  sleep() method doesn't release the lock.
	wait is the method of Object class -  sleep is the method of Thread clas
	wait is non static Method 			- sleep is static method
	
	

	wheneever we use wait() and notify() inside the method,the method needs to be synchronized

**wait() and notify()
wait() will causes the current thread to wait untill another thread invokes notify() or notifyAll() method
notify() wakes up a single thread that is waiting to accept to use the resource (should be the first thread which used wait())
notifyAll() will wake up that are waiting to access the resource

Threads can be implemented in 2 ways. 
1. By extending Thread class
		
			public class MyThread extends Thread {
		   public void run(){  
		    System.out.println("thread is running...");  
		  } 
		   public static void main(String[] args) {
		     MyThread obj = new MyThread();
		     obj.start();
			}

			Since multiple inheritance is not possible we can use a Runnable interface to create a thread
		** 1000 millisecond is 1 second

2. By implementing Runnable Interface

			public class MyThread implements Runnable {
   public void run(){  
     System.out.println("thread is running..");  
   }  
   public static void main(String[] args) {
     Thread t = new Thread(new MyThread());
     t.start();
}


**Extends Thread class vs Implements Runnable Interface?

	Extending the Thread class will make your class unable to extend other classes, because of the single inheritance feature in  JAVA. However, this will give you a simpler code structure. If you implement Runnable, you can gain better object-oriented design and consistency and also avoid the single inheritance problems.
	If you just want to achieve basic functionality of a thread you can simply implement Runnable interface and override run() method. But if you want to do something serious with thread object as it has other methods like suspend(), resume(), ..etc which are not available in Runnable interface then you may prefer to extend the Thread class.


**Thread Life cycle in Java
	The start method creates the system resources, necessary to run the thread, schedules the thread to run, and calls the thread’s run method.

	A thread becomes “Not Runnable” when one of these events occurs:
	If sleep method is invoked.
	The thread calls the wait method.
	The thread is blocking on I/O.
	A thread dies naturally when the run method exits.

**Thread.join()-The join() method waits for a thread to die

	Why we use join() method?
	In normal circumstances we generally have more than one thread, thread scheduler schedules the threads, which does not guarantee the order of execution of threads.
For example lets have a look at the following code:
			

		Thread th1 = new Thread(new MyClass(), "th1");
      Thread th2 = new Thread(new MyClass(), "th2");
      Thread th3 = new Thread(new MyClass(), "th3");
         
      // Start first thread immediately
      th1.start();
         
      /* Start second thread(th2) once first thread(th1) 
       * is dead
       */
      try {
          th1.join();
      } catch (InterruptedException ie) {
          ie.printStackTrace();
        }
      th2.start();
         
      /* Start third thread(th3) once second thread(th2) 
       * is dead
       */
      try {
          th2.join();
      } catch (InterruptedException ie) {
           ie.printStackTrace();
        }
      th3.start();
         
      // Displaying a message once third thread is dead
      try {
          th3.join();
      } catch (InterruptedException ie) {
            ie.printStackTrace();
        }  
      System.out.println("All three threads have finished execution");
   }
}


**Why don’t we call run() method directly, why call start() method?

	If we call just run method then it will run just like a normal method and we will be not be able to take the advantage of multithreading
	If we call run method through start method a seperate new Thread gets allocated for its execution and all these threads would run simultaneously

**Can we start a thread twice in Java? 
	The answer is no, once a thread is started, it can never be started again. Doing so will throw an IllegalThreadStateException.

	method isAlive(): Determine if a thread is still running.

** How to achieve Thread Safe



1. Using the stateless Implementation

		public class StateLess{

		public static int addValue(Integer value){
		value=value+1;
		return value;
		}
		}		
IN the above example
The method neither relies on external state nor maintains state at all. Hence, it’s considered to be thread-safe and can be safely called by multiple threads at the same time.

Therefore, stateless implementations are the simplest way to achieve thread-safety.


2.Making a class Immutable-
	The easiest way to create an immutable class in Java is by declaring all the fields private and final and not providing setters

			public class MyClass {
	   			private final int number;

	   			public MyClass(int number) {
	    		this.number = number;
	   			}

	   			public int getNumber() {
				   return number;
				   }

		}

3. Synchronized Method

	public synchronized void incrementCounter() {
	    counter += 1;
	}

	We’ve created a synchronized method by prefixing the method signature with the synchronized keyword.

	Since one thread at a time can access a synchronized method, one thread will execute the incrementCounter() method, and in turn, others will do the same. No overlapping execution will occur whatsoever.

Synchronized Collection

	We can make the collections also synchronized
	Collection<Integer> syncCollection = Collections.synchronizedCollection(new ArrayList<>());
	Thread thread1 = new Thread(() -> syncCollection.addAll(Arrays.asList(1, 2, 3, 4, 5, 6)));
	Thread thread2 = new Thread(() -> syncCollection.addAll(Arrays.asList(7, 8, 9, 10, 11, 12)));
	thread1.start();
	thread2.start();

MultiThreading
 Multithreading is main done to increase the execution speed, One thread will access one core so multi threads will access multiplt cores in cpu

 2.Synchronous tasks
To take heap dum kill-3

 Thread dead lock- When the thread 1 is holding a resource lock of thread 2 and thread 2 is holding the resource lock of thread 1 then one it will be thread lock


 /*
     * This method request two locks, first String and then Integer
     */
    public void method1() {
        synchronized (String.class) {
            System.out.println("Aquired lock on String.class object");
            synchronized (Integer.class) {
                System.out.println("Aquired lock on Integer.class object");
            }
        }
    }
    /*
     * This method also requests same two lock but in exactly
     * Opposite order i.e. first Integer and then String. 
     * This creates potential deadlock, if one thread holds String lock
     * and other holds Integer lock and they wait for each other, forever.
     */
    public void method2() {
        synchronized (Integer.class) {
            System.out.println("Aquired lock on Integer.class object");
            synchronized (String.class) {
                System.out.println("Aquired lock on String.class object");
            }
        }
    }
}

solution is to maintain the order

 public void method1() {
        synchronized (Integer.class) {
            System.out.println("Aquired lock on Integer.class object");
            synchronized (String.class) {
                System.out.println("Aquired lock on String.class object");
            }
        }
    }
    public void method2() {
        synchronized (Integer.class) {
            System.out.println("Aquired lock on Integer.class object");
            synchronized (String.class) {
                System.out.println("Aquired lock on String.class object");
            }
        }
    }
}


while

**Comparator vs comparable

	Comparator has compare method
	comparable has compareTo method

	Comparator is used to compare more than one field
	comparable is used to  one field


	Comparator- Actual class is not effected, Implemented in the seperate class
	comparable- Actual class is effected

InnerWorking of HashMap

	HashMap uses a technique called hashing,If 2 objects are equal then they must have same hashcode
	Every object will have a hascode method which gives the hashcode of that object eg 231245 ,hashcode is a set of integer numbers.

HasMap internally has a array of Node (each Node is a linked list)
Node will have ie Node<k,v> will have

				int hashcode;
				 key;
		 		value;
				 Node<k,v> next;

the lenght of the array is by default 16(index will be 0-15)
When we try to insert a value to hashmap using put method, the hashcode of the key will be calculated and
uisng the formula
ie index=hashcode & (n-1) (& means modulus operation and n=16)
whatever index we get we will insert the keyvalue pair in that node.If there are 2 keys with the same index then the first inserted record in that node, the  "next" poniter will be pointing to this ne record.

HashMap will allow us to store a "Null" key, "Null" has a hashcode =0 so index of null key will be always 0

To get the value of the key we use the same index calculation and once we get the index we compare the hashcode value stored in the index with the hashcode of the Key value and the string key will also be compared using equals method. If both will match then the particular key will be retuned


In java 8
 If the number of duplicated index reaches more than the threshold ie TreeIFY_Threshold=8 then node switches from a linked list to a balanced tree  or binary tree to improve the performance

 Balanced tree means the heavier hashcode will be moved to the right side of the tree and the lighter one will be moved to the left.
 If the hascodes are equal then we compare the keys

 A binary search tree is a * sorted binary tree, where value of a node is greater than or equal to its * left the child and less than or equal to its right child.

 Read bst-https://www.youtube.com/watch?v=81PpYQ0AN_w


 ConcurrentHashMap vs SynchronizedHashMap-Both are used to achieve thread safe


 *SynchronizedHashMap 	maintains the lock at object level , to perform put or get we need to acquire the lock

 *ConcurrentHashMap 	mainitains the lock at bucket level
 						read operation doesn't require a lock. So any number of threads can perform a get operation on it.

						If thread1 wants to perform put operation in segment 2 and thread2 wants to perform put operation on segment 4 then it is allowed here

Difference btw HashMap and HashTable

Hashmap is not thread safe and it is not synchronized
HashTable is threads safe and it is synchnonized

HashMap is fast
HashTable is slow

HashMap can allow one null key
HashTable does not allow null key


In hasMap and hashTable the insertion hashMap is not fixed, but in linked HashMap the isertion order is fixed.


ConcurrentHashMap vs Hashtable vs Synchronized Map- All the 3 are threadSafe

		The only difference between Hashtable and Synchronized Map is that later is not a legacy and you can wrap any Map to create it's synchronized version by using Collections.synchronizedMap() method.

		

Read more: https://javarevisited.blogspot.com/2011/04/difference-between-concurrenthashmap.html#ixzz5yjFPtYkJ



HasSet vs HashMap
HashSet allows one null value HashMap allows one null key and any number of null values
HaShSet is a implemention of Set Interface, HashMap is a implemention of Map Interface
HashSet we have add , HaspMap we have put


TreeHashMap is a sorted HashMap


** TreeMap
	Some of the important points to remember about TreeMap in java are;

	Apart from implementing Map interface, Java TreeMap also implements NavigableMap and indirectly implements SortedMap interface. TreeMap also extends AbstractMap class.

	TreeMap entries are sorted in the natural ordering of its keys. It also provides a constructor to provide Comparator to be used for ordering. So if you are using any class as key, make sure it’s implementing Comparable interface for natural ordering. Check out java collections interview questions to understand the importance of these methods.

	Java TreeMap implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations.

	TreeMap is not synchronized and hence not thread-safe. For multithreaded environments, you can get a wrapped synchronized using Collections.synchronizedSortedMap method.

	TreeMap methods to get keyset and values return Iterator that are fail-fast in nature, so any concurrent modification will throw ConcurrentModificationException.
	
	TreeMap in java doesn’t allow null keys, however you can have multiple null values associated with different keys.


**Set Collection

	Set is a collection which doesnot allow duplicate values

	HashSet,LinkedHashset,TreeSet etc
	TreeSet is used for sorting

	HashSet INternally uses has map to insert the data 

	eg in the documentation
		public boolean add(E e) {
   return map.put(e, PRESENT)==null;
}


to get the value from hasSet , the iterator method will return
	public Iterator<E> iterator() {
        return map.keySet().iterator();
    }

Advantages of Data Structure
	Reusability
	Efficiency
	Abstraction

    **Stack-LIFO
     Stack is a linear list in which insertion and deletions are allowed only at one end, called top.
	Stack is a abstract datatype. I uses LIFO-Last In First Out,
	It has features like 
	push - to add a element
	pop- to delete a element
	peek-to view a element
	In stack we have only one entry point
	If we are adding more value to the fixed size stack then we get overflow error
	Underflow error is when you try to get value from a empty stack

**Queue-FIFO
	Queue is a linear list in which elements can be inserted only at one end called rear and deleted only at the other end called front.
	Queue used FIFO and it has enqueue for insertion and dequeue for deletion
	WE need to create enque,dequeue isEmpty,isFull,getSize methods with normal logic

**Linked List
	LinkedList is an implementation of both a queue and a stack

	Poll vs Pop
	Poll will return null if the list is empty and Poll is also used to remove the head element
	Pop will throw java.util.NoSuchElementException and Pop is used to remove and return the head element
	

	Other methods are 
	peek()
	peekFirst()
	peekLast()

	3 types of linkedList
	1.Single linked list
	2.doublylinkeedList
	3.CircularLinkedList

Array vs LinkedList

Array size if fixed, LinkedList size is dynamic
Array is faster for adding,deleting, Linked list is slower for these operations
Array consumes more memory, In linked List the memory can be redumped to heap



*Tree
	
	This data structure uses a concept of Node

	TopNode is root node
	lines which connect each node is edge
	Nodes which donot have any child are called Leaf Node

**Binary Tree

	Binary tree is a Tree which does not have more than 2 nodes, all the nodes can have 0,1 not more than 2 node

	Types in Binary Tree

	1.Strict Binary Tree- Either 0 or 2 nodes or childrens
	2.Full Binary Tree - Where all the childrens are on same level( they will have same right and left nodes)
	3.Complete Binary tree where the level of child nodes are l and l-1

	Depth- Distance btw Root Node
	Height-Height till last child node

	Height of the tree = height of root node




Read more: https://javarevisited.blogspot.com/2015/10/how-to-implement-binary-search-tree-in-java-example.html#ixzz5vtwsQjZh

**ArrayList vs Linked List

	ArrayList is fast for gettig the data
	LinkedList is fast for manupulating the data

	ArrayList uses dynamice resiazable array
	LinkedList uses doubly linked List



**Inner Class

	
	1.The scope of a nested class is bounded by the scope of its enclosing class. Thus in above example, class NestedClass does not exist independently of class OuterClass.
	2.A nested class has access to the members, including private members, of the class in which it is nested. However, reverse is not true i.e. the enclosing class does not have access to the members of the nested class.
	3.A nested class is also a member of its enclosing class.
	

	For inner class the class file will be created name will be A$B.class where A is the outer class and B is the inner class


	There are 3 types 

	1.Non Static class
		To Acess the inner class variables we have to the following
	we have to create a outer class Instance and using that we have to access the inner class variables

		Outer o=new Outer();
		Outer.Inner u= o.new Inner();

		If we want to access the outer class non static variables then we dont have to create the objects of outer class

		public class InnerRun  {
		private int it=10;
		int j=20;
	
	
		public class Ulai{
		public void getUlai(){
			
		System.out.println(j+it);
		}
	}

		}


	2.Static Class
		**If we make the inner class static we dont need to create the object of the outer class,
		**Only Nested class can be static , the outer class cannot be static

		To Acess the non static variables inside a static class
		StringUnique.Inside u = new StringUnique.Inside();
		u.run();

** 	To acess the non static inner class , we have to create Object of the outer class
	To acess the  static inner class , we do not have to create object of outer class

	A static class cannot access non-static members of the Outer class. It can access only static members of Outer class.


	3.Anonymous Inner Classes

	**	Age oj1 = new Age() {
            @Override
            public void getAge() {
                System.out.print("Age is "+x);
            }
        };

	Age is a interface,
** Anonymous Objects are objects without reference
	new A().showEmployee();// This does not have a reference and hence it will not utilize the stack memory , it will use only heap

	Since anonymous objects dont have reference , they are eligible for garbage collection

**	What are inner beans

In Spring framework, whenever a bean is used for only one particular property, it’s advise to declare it as an inner bean. And the inner bean is supported both in setter injection ‘property‘ and constructor injection ‘constructor-arg‘. Like Inner classes are the classes which are defined inside the scope of another class. Similarly inner beans are the beans which are defined in the scope of another bean.

<bean id="outer_bean" class="OuterBean">
      <property name="innerbean">
           <bean  class="InnerBean"/>
      </property>
</bean>

In this case an instance of InnerBean class will be created and wired in to innerbean property of OuterBean class.We should not use Id or name for them and their default scope is prototype


---------------------------------Java Upgrades--------------------------------------------------------------------------------------------

**In java 8 

1.we can create methods in interface

	Inside interface you can define a method with a default keyword and for defining static methods we dont have to use default keyword
	eg:

	public interface employee{

	public Employee getEmployee();

	default Employee findEmployee(int employeeId){

	}
	}

	If there are 2 interfaces which hav deined a same method in them then the implementing class shoudl also define the method.
	this is only applicable if both the interfaces have  the same method.

	Class has more power than interface

	**while using default methods we cannot override the methods present in the object class

	**Differences between static and default methods in Java 8:

	1) Default methods can be overriden in implementing class, while static cannot.

	2) Static method belongs only to Interface class, so you can only invoke static method on Interface class, not on class implementing this Interface


2.We got lambda functions

	Java lambda expression is treated as a function, so compiler does not create .class file. It is usuall used to implement a functional Interface

	**	@FunctionalInterface -any class marked with the above annotation can have only one abstract method and it can have any number of default methods. These are mainly added to support lambda expressions
	java.lang.Runnable is a example for functional Interface

	eg: Adding Functiona Interface

				@FunctionalInterface
				public interface FunctinalLambda {

					 abstract Employee getEmployee(int empployeeId);
					
					 default Employee showEmployee(int empployeeId){
						return  new Employee(10, "mmmm");
					 }
				}

This is the implementation, WE donot have to create a new class for the implementation instead we can

							public class RunLambda {

					public static void main(String[] args) {
						FunctinalLambda lambda = i ->  new Employee(i, "Thejas");
						
						
						lambda.getEmployee(2);
					}
				}


	**In java we have a internal foreach loop for a list , the input parameter for the internal forEach(java.util.function.Consumer), we have to pass a consumer object

	Consume is a functional Interface it has accept method

	java.util.function.Consumer was introduced in java 8

		eg List<Employee> employeeList=new ArrayList<>();

		employeeList.forEach(i -> sop(i)); //This will iterate the list



	**Anonymus Innner class- A class without any name used inside a class if we use there will not be a innclasss.class file created

	Limitations Of Lamnda Functions

	1.we cannot change the value of local variables , because inside the lambda funtion the copy of the local variable is already stored so complier restricts us from changing the value
	2. WE can only implement one method for a reference


3.Stream api

	A java stream is a component which provides functionality for processing the elements during iteration

		Stream spi are used to method chaining

To use stream we need to 
	1.Obtain a stream
	2.call zero or non tearminal operation on stream
	3.call terminal operartion  on stream

	Intermidiate Operation
	INtermidiate operations add element processing operations to the stream, but does not start the iteration of the elements.
	 Intermediate operation is lazy and Terminal operations is not
	 WE cannot repeat the intermidiate Operation on a stream , it will not have any compitaion error but it will throw exception.
	 we need to call the method using the new stream returned from the previous stream

	When you invoke an intermediate operation on a stream, the operation is not executed immediately. It is executed only when a terminal operation is invoked on that stream
	You can chain multiple intermediate operations and none of them will do anything until you invoke a terminal operation
	All intermediate operations return Stream (can be chained), while terminal operations don't. 

**Intermediate Operations are:

	filter(Predicate<T>)
	map(Function<T>)

Terminal operations produces a non-stream (cannot be chained) result such as primitive value, a collection or no value at all.

**Terminal Operations are:

	forEach
	forEachOrdered
	toArray


**Call by Method or Method Reference  in java 
	eg
	List<String> name=Arrays.asList("Naven","manoj","Raju");

	name.forEach(System.out :: println); // WE are not using lambda here , we are using method reference here

	the above line is called function programming , here we are passing the method inside a method and we should use class name followed by 2 double colns followed by method name.
	When passing the method the class should be a functional Interface


**Java 9
	
	The collectionFactory method, java has added new static method in list,set,map interface whihc will allow us to create immutable objects of these collections
	eg List.of();
		Set.of();
		Map.of();

	1.Jigsaw project-
	 Jigsaw project helps us to achieve modularity

	 rt.jar- runtime jar- It has all the classes like string,system all belong to this jar

	 WE are not using jar we r using modules which is required for a particulr project instead of using one big jar

	2.REPL- Read Evolve Print Loop- with the help of jshell- It is helpful for learing, to write sop statemtne we dont have to create a class or method we just have to use the jshell terminal.

	3.Enhancement of stream api
	4.In java9 we can have private methods defined in interface
	

**Java11

In string there is a method called repeat(3);
which will repeat 3 times

isBlanck()- Cheks whether the given string is blank

WE can use annotations in lambda expressions 
Consumer<String> consumer=(@Depriceted var i) -> sop("this is the string");


	
**AOP-Aspect Oriented Programming
It is used to increase the modularity by cross cutting concerns, A cross cutting concern is a concern that effect the whole application
and it should be centralized in a single location eg logging,transactionmanagement etc


Steps in aspects
1. Write Aspects using @Aspect annotation while creating a class
2.In the same class create methods with @Before annotaion specifiying before which method it has to be executed

	eg 
	@Before("execution(public String com.tsoft.Employee.getName())")
	public void getMessage(){
	sop("get message")
	}
Also in spring.xml we have use a tag
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



Spring boot
In spring mvs we have to configurations like class path scan,dispatcher servlet,web jars etc

eg if some one is using spring-mvc jar then they would need dispacteher servlet dependency or 
how about autoconfiguring a data source if hibernate is in the class path

Auto configuration in spring means depending on the jar files present in the classpath and the exisiting confuration spring-boot will provide its own default configuration


WE have sprig initilizar is used to create ready to run projects provided by spring- start.spring.io is the link

GroupId is the reverse domain name
Artifact Id is the project name

All the spring auto configure will be present in sprint-boot-autoconfigure.jar/META-INF/spring.factories

INside this file there wil be some anotations like

@Conditional.class {{DataSource.class}} -If will autoconfigure only if there is datasource.class in the class path

@ConditionaOnMissingBean- It will autoconfigure of there is no other  bean matching this name


SpringApplication.run(PecokApplication.class, args);

is a static method , when we run this method, it will
1.set up default configuration
2.starts spring application context
3.performs claapath scan
4.starts tomcat server


Hibernate

**Dialect class is java class, which contains code to map between java language data type database data type.

	In Hibernate-cfg.xml

					<hibernate-configuration>
		   <session-factory>
		       <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
		       <property name="hibernate.connection.password">orion123</property>
		       <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/orion_db</property>
		       <property name="hibernate.connection.username">root</property>
		       <property name="hibernate.default_schema">orion_db</property>
		       <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
		   </session-factory>
		</hibernate-configuration>

States of Hibernate Objects

1.Transcient State- It is a state of the object before its given to hibernate to save in the database .
2.Persistant- This is state where the object is given to hibernate to handel or to save in the database
3.Detached is a state similar to transcient , once the session is closed the object becomes detached

when we do session.delete(user) object goes from persistant to transcient state

To update a object only if any changes are made then we need to add @ori.hibernate.annotations.Entity(SelectBeforeUpdate=true) below the entity annotation of pojo class. This means we are telling hibernate to run a selcet to check the data in database before updating

SessionFactory vs session

SessionFactory is common for one application and it is thread Safe, it uses second leve caching

Session is used to perform curd operations and it is not thread safe , it uses first leve caching


Caching in hibernate
we have 
1st level caching
2nd level caching eg ehcaching

By default first leve caching is enabled by hibernate
 to enable second leve cache we have to download the required second level cash through pom.xml
 and set second leve cache to true and mention the provider in hibernate.cfg.xml file
 and use @2 anotations in the entity class

Get vs load

load will not hit the database if we donot use the object and it gives ur proxy object it will only give the object when we use it
load will throw object not found exception

get will hit the database and it will give us real object and if there is not object it will give null

**Transaction 
	A transaction is a unit of work with few steps performed by a data base management systme against a database
	They are all or nothing ie either all the steps should be completed or al the steps should be rolled back
	A transaction should take care of Acid Properties
	A- Atomicity- Ensure that all the steps are successful or all of them fail
	C- Consistant-The system should be left in a consistent state if either on success or failure
	I-Isolation- MUltiple users should be able to work without any issue ie concurent read or writes
	D-After the sucessful operation the data shoudl be stored permentaly





**	EntityManager
	 is used to interact with Database we can add,update or delete a record in database
	To use entitymaneger we have to use entitymanagerfactorybean to get the entitymanagerobject

		In Orion we use 
		<bean
				class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"
				id="entityManagerFactory">
				<property name="dataSource" ref="dataSource" />
			</bean>
		as entityManagerFactory	 in applicationcontext.xml


		Persist will save the data in database and also we can make future update if we are making any change
		Merge wll save the data but If we want to update then again we have to call merge

		MyEntity e = new MyEntity();

		// scenario 1
		// tran starts
		em.persist(e); 
		e.setSomeField(someValue); 
		// tran ends, and the row for someField is updated in the database

		// scenario 2
		// tran starts
		e = new MyEntity();
		em.merge(e);
		e.setSomeField(anotherValue); 
		// tran ends but the row for someField is not updated in the database
		// (you made the changes *after* merging)

**EntityManager vs Session
		EntityManager is a standardized api of jpa
		Session is a hibernate specific api

		EntityManager is a adopter class which wraps a session

			We can get seesion object from entityManager

			Session session = entityManager.unwrap(Session.class);

JPA is a specification it is not a implementation 



-----------------------------

2.Type script questions and variables
3.events and its advantage
4.routing and its advantage
5.pipes
6.current versions of spring,hibernate,angular


Array Programs

 https://javarevisited.blogspot.com/2015/06/top-20-array-interview-questions-and-answers.html

https://www.javacodegeeks.com/2013/11/spring-security-behind-the-scenes.html
Spring security behind the scenes
Mongodb questions

MultiThreading
Different scopes in sprng
@Restcontroller and @Controller implementation
Spring mvc+angular
https://examples.javacodegeeks.com/enterprise-java/spring/mvc/spring-mvc-and-angular-6-example/