Important topics and Explanation


UML diagram more info https://www.youtube.com/watch?v=6XrL5jXmTwM

Java is platform independent but jdk,jre,jvm are all platform dependent.

JDK- Java developemt kit 
it is use to develop and run java application, JDK is platform dependent

JDK=JRE+developement tools

JRE- Java Runtime Envrionment 
is used in the client machine just to run- 

JRE=JVM+library classes

JVM is a virtul machine which is a interpretor and it is responsible for line by line execution.JVM converts the byte code into machine level language
 JVM is also platform dependent and provides core java functions like memory management, garbage collection, security etc.
 WE need to have different jvm for different operating system

Memory leak
	One of the core benefits of Java is the automated memory management with the help of the built-in Garbage Collector (or GC for short). The GC implicitly takes care of allocating and freeing up memory, and thus 	is capable of handling the majority of memory leak issues

	A Memory Leak is a situation where there are objects present in the heap that are no longer used, but the garbage collector is unable to remove them from memory
	unreferenced objects are removed by the garbage collector but the referenced ones are not removed

	Static Variables can cause memory leak
		Static variables cannot be elected for garbage collection while the class is loaded.
		 They can be collected  either by setting them to null if we dont need them or when the respective class loader (that was responsible for loading this class) is itself collected for garbage.

		A class or interface may be unloaded if and only if its defining class loader may be reclaimed by the garbage collector [...] Classes and interfaces loaded by the bootstrap loader may not be unloaded.

	Database connections,input streams, and session objects if not closed with finaly blocks can cause memory leak
		When using Java 7+, we can make use of the try-with-resources block

	Improper equals() and hashCode() Implementations
		When defining new classes, a very common oversight is not writing proper overridden methods for the equals() and hashCode() methods.

		HashSet and HashMap use these methods in many operations, and if they’re not overridden correctly, they can become a source for potential memory leak problems because if you want to insert many person objects to a map as key then it will use the equals and hashcode methods of the person class, so we need to implement it properly or else we will have many objects for example
		  map.put(new Person("jon"), 1);  
		  map.put(new Person("jon"), 1); both are different if the equals and hascode are not implemented properly.

	ThreadLocal
			Memory Leaks with ThreadLocals

		ThreadLocals are supposed to be garbage collected once the holding thread is no longer alive. But the problem arises when we use ThreadLocals along with modern application servers.
		
		Modern application servers use a pool of threads to process requests, instead of creating new ones (for example, the Executor in the case of Apache Tomcat). Moreover, they also use a separate classloader.
		
		Since Thread Pools in application servers work on the concept of thread reuse, they’re never garbage collected; instead, they’re reused to serve another request.
		
		If any class creates a ThreadLocal variable, but doesn’t explicitly remove it, then a copy of that object will remain with the worker Thread even after the web application is stopped, thus preventing the 		object from being garbage collected.
		
		How to Prevent It?
		
		It’s good practice to clean-up ThreadLocals when we’re no longer using them. ThreadLocals provide the remove() method, which removes the current thread’s value for this variable.
		Don’t use ThreadLocal.set(null) to clear the value. It doesn’t actually clear the value, but will instead look up the Map associated with the current thread and set the key-value pair as the current 			thread and null, respectively.
		It’s best to consider ThreadLocal a resource that we need to close in a finally block, even in the case of an exception::
		 
		
		try {
		    threadLocal.set(System.nanoTime());
		    //... further processing
		}
		finally {
		    threadLocal.remove();
		}
ThreadPool https://www.youtube.com/watch?v=sIkG0X4fqs4
	If you want to execute 1000 tasks then you can use ExecutorService to get the fixed threads say 10 threads which can be re used to complete the 1000 tasks all the tasks will be moved to a thread safe ques to that the can be picked for our thread, usually Blockingqueue is used because it is thread safe

	Poll size - If we have cpu intensive operation then we should use number of threads =number of cpu because at a time we can use only 4 threads because each kava thread =1 os thread
			int coreCount=Runtime.getRunTime().availableProcessors() will give the processor count and that can be set as the pool size.
		    If it is the Io operation or get data from database then once the request is sent , the threads goes into wait state so now we can re use these threads so in this case we can set the threadpool size to some big number say 100
			Too many threads will have more memory consumption also if our server is running other applications then we cannot assume that all 100 threads will be used for our operation

	Type of ThreadPool

	1.FixedThreadPool

	2.CachedThread pool- It will have one synchronous queue whcih will store one task and it will see if any threads are avilable if not it will create a new thread ,add it to the pool
		and execite the task in this case if we do not specify the threadpool size so anynumner of threads can be created if there are no free threads availabel and this service will also kill the thread if the thread is idal for 60 seconds to save the memory

	2.ScheduledThreadPool

	3.SingleThreadPool

 Members of the class-fields,methods and inner classes

 variables decalred using final keyword can only be initialized in a constructor.
 static final variables can be  initialized inside only inside a static block.

 final methods are inherited but are not overridden

 final keyword cannot be used to constructor because constructors are not inherited.

 We cannot create a final interface(eg String class)
 we cannot use abstract and static keywords together(y.... think monkey ??..think!!)

 A final class cannot be extended, we should use the final class if we do not want inheritance,
 If we want to promote composition over inheritance.

 1-No, declaring the constructor as final is not possible.We will get complitation error saying  final modifier not allowed.
 Final means you cannot override it. Since Constructor declarations are not members. They are never inherited and therefore are not subject to hiding or overriding. A parent class constructor can be invoked.

 *If we use string1+strng2+....

 then java compiler will complie the code by replacing + with StringBuilder.append
 but if there is only 2 string concatination , then complier will keep it as it is
 
 StringBuffer is thread safe and StringBuilder is not thread safe
 StringBuffer is slower when compared to StringBuilder.

 *Garbage Collection

 Garbage collector is best example of Daemon thread as it is always running in background.
 Finalization:Just before destroying an object, Garbage Collector calls finalize() method on the object to perform cleanup activities.
    Once finalize() method completes, Garbage Collector destroys that object.

Stack is used to method execution, Heap is used for storing objects

Object class is the only class that does not extend any other class,every class is implicitly a subclass of Object.

Static members,private,constructors cannot be over rided and access specifiers can be changed but cannot be reduced.
Visibility in the child can be more than Parent class but cannot be less than the parent class.

String Interning
	Thanks to the immutability of Strings in Java, the JVM can optimize the amount of memory allocated for them by storing only one copy of each literal String in the pool. This process is called interning

Before Java 7, the JVM placed the Java String Pool in the PermGen space, which has a fixed size — it can’t be expanded at runtime and is not eligible for garbage collection.

	The risk of interning Strings in the PermGen (instead of the Heap) is that we can get an OutOfMemory error from the JVM if we intern too many Strings.

	From Java 7 onwards, the Java String Pool is stored in the Heap space, which is garbage collected by the JVM. The advantage of this approach is the reduced risk of OutOfMemory error because unreferenced Strings will be removed from the pool, thereby releasing memory.

String s1="thejas"
String s2="thejas"// String pool does not allow duplicated objects so only one object gets created and so s1==s2

but String s3=new String("thejas")// Object is created in heap so s1!=s3

		** 			private		     			default     			protected	public
		Class			No					Yes				No		Yes
		Nested Class		Yes					Yes				Yes		Yes
		Constructor		Yes					Yes				Yes		Yes
		Method			Yes					Yes				Yes		Yes
		Field			Yes					Yes				Yes		Yes

		A class can only be default,public and  Inner class can be private,default,protected,public

		Default is also called as package private
		Protected =Can be acessed by subclass or package private

		For overloading the return type does not matter only methodname and argument list matter

Constructor is a block with no return type, It has same name as the class, It is not a member of a class so its not inherited,It can only be invoked.

A subclass inherits all of the public and protected members of its parent, if the subclass is present in the same packge , then it can access the package private or default members also.

A nested class has access to all the private members of its enclosing class—both fields and methods. Therefore, a public or protected nested class inherited by a subclass has indirect access to all of the private members of the superclass.

static methods are inherited but not overridden, if you try to override then the static method in the parent class will be hidden
 variables declared using static final needs to be initialized

 
 Serializable is a marker interface

Casting of Objects
	MountainBike is descended from Bicycle and Object. Therefore, a MountainBike is a Bicycle and is also an Object, and it can be used wherever Bicycle or Object objects are called for.

	The reverse is not necessarily true: a Bicycle may be a MountainBike, but it isn't necessarily. Similarly, an Object may be a Bicycle or a MountainBike, but it isn't necessarily.

	Casting shows the use of an object of one type in place of another type, among the objects permitted by inheritance and implementations. For example, if we write

	Object obj = new MountainBike();
	then obj is both an Object and a MountainBike (until such time as obj is assigned another object that is not a MountainBike). This is called implicit casting.

	If, on the other hand, we write

	MountainBike myBike = obj;
	we would get a compile-time error because obj is not known to the compiler to be a MountainBike. However, we can tell the compiler that we promise to assign a MountainBike to obj by explicit casting:

	MountainBike myBike = (MountainBike)obj;
	This cast inserts a runtime check that obj is assigned a MountainBike so that the compiler can safely assume that obj is a MountainBike. If obj is not a MountainBike at runtime, an exception will be thrown.

	we can user instanceOf method to avoid the run time error
		eg
			if (obj instanceof MountainBike) {
    		MountainBike myBike = (MountainBike)obj;
		}

Custom Annotations

Need for creating custom annotations

1.For documentation purpose- Annotations will not have any functionality in this case

2.Input for a java code processor

3.Input for java library that access our annotation at runtime via java reflection

Annotations can be used in class,method,constructors,fields , parameters(See @Target(ElementType.Type) options)

		@Retention(RetentionPolicy.RUNTIME)

			RetentionPolicy.Source-It will only be present in the source code
			RetentionPolicy.Class- It will be present both in source code and class file(Compiled file)
			RetentionPolicy.Runtime- It will be availabe in runtime as well

		@Target(ElementType.Type)
		@Inherited can be used in a annotation to indicate it can be inherited
		@Documented will document the annotation in java doc

1.Annotations without any fields are called as Marker Annotations
2. If the annotation has one field then it is called Single value annotaion
#There is a  interface called Annotation, all the annotations created are subclass of this Interface

**Creating custom Annotation
1.WE need to use @interface annotation 


eg 1
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.Type)
	public @interface JsonSerializable {
	}

	Above example is a marker interface which does not have any methods,has runtime visibility, and we can apply it to types (classes)

eg @interface smartPhone{
	
	String os();
	int version();
}

we can now use @smartPhone(os="symbian",version="1") as annotation

	Using ReflectionApi we can get the value or features of the object

	eg
		 if(new GreenApple().getClass().isAnnotationPresent(Barcode.class)){
            System.out.println(new GreenApple().getClass().getAnnotation(Barcode.class));
        }

        for the above code to work the retentionpolicy should be runtime

        @Target(ElementType.TYPE)*/
		@Inherited
		@Documented
		@Retention(RetentionPolicy.RUNTIME)
		public @interface Barcode {

	    public String type() default "Main Type";

	    public int price() default 100;

		}


Cohesion refers to the level of a component which performs a single well-defined task.

In java we have call by value there is no call by reference in java because we do not have pointers
In java whatever changes we make it will be only applicable inside the method

Call by value means calling the function with parameter as value

call by reference means calling the function with paramater as reference

Association
	It is a relation between 2 independent classes establised through their objects

	Composition(has a) and Aggregation(Is a) are the 2 forms of Association.

	Aggregation is a has a relationship(Inheritance - method overriding)

		It is a unidirectional association eg department has students but vicecersa is not possible

		In Aggregation, both the entries can survive individually which means ending one entity will not effect the other entity

	Composition is a restricted form of Aggregation in which two entities are highly dependent on each other.
				It represent parts of relationship, when one is destroyed the dependent object is also destroyed

	Composition is a strong Association whereas Aggregation is a weak Association.

Inheritance

	Inheritance will make the sub classes unique by putting the commmon implementations in the super class.

	A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.

Object class in the super most class in java

	The Object class is the top of the class hierarchy. All classes are descendants from this class and inherit methods from it. Useful methods inherited from Object include toString(), equals(), clone(), and getClass().

Interface
	In the Java programming language, an interface is a reference type, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types

	Interface can be public or default(Package Private)

	All methods are by default public
	All the constants are by default public static final so you dont have to use these modifiers.

	For Non static methods if the child method has the same name , then it will be overrided in the child class(This happens at runtime).
	For static methods,static fields,non static fields the parent method will be hidden not over ridden(this happens at compile time)

	Foo f = new Bar();
        f.instanceMethod();//child method gets executed
        f.classMethod();//parent method gets executed

        If u create a abstract method (Y) in the parent and if u declare the same metohod(Y) as abstratc in ur child interface then the class which will implement the child will have to implement the abstract method (Y) , the parents default implementation will not be available to it

        Default methods can be overridden

        https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html

  **Comparator vs comparable

      * Comparable - compareTo(Object o)

	        If any custom class wants to use Arrays.sort or Collections.sort then it should implement Comparable.

	        In Comparable we modify the pojo class,Sometimes we might not be able to modify the class
	        Comparable can be used only for natural ordering or default sorting.

	        NullPointerException - if the specified object is null
		ClassCastException - if the specified object's type prevents it from being compared to this object.

      * Comparator- compare(Object o1,Object o2)

         It is a good practise to Seralize the comparator as they may be used as ordering methods in serializable data structures (like TreeSet, TreeMap). In order for the data structure to serialize successfully

         Arrays.sort or Collections.sort will take one more argument which take Comparator as argument.

         NullPointerException - if the specified object is null
		ClassCastException - if the specified object's type prevents it from being compared to this object.

			First object with Second object will be ascending
			reverse will be descending



	Comparator has compare method
	comparable has compareTo method

	Comparator is used to compare more than one field
	comparable is used to  one field


	, Implemented in the seperate class ,Comparator- Actual class is not effectedate class
	comparable- Actual class is effected

	Comparable is used to default sorting,Comparator is used for custom sorting

	Useful methods of Comparator

	Comparator<Chair> cmp=Comparator.comparing(Chair :: getName);
		Collections.sort(cl,  cmp);


		Comparator ch4=	Comparator.comparing(Chair::getName).thenComparing(Chair::getSize);
		Collections.sort( cl,ch4);

		Comparator ch4=	Comparator.comparing(Chair::getName).reversed();
		Collections.sort( cl,ch4);

**Collection

	Methods like add,addAll,remove,removeAll,Iterator ,clear these methods are inhertited from collection Interface.

 **List
       	It is a ordered collection which allows duplicate.

       	You can convert any collection to any other collection( set collection into arraylist and vice versa) by using a constructor.

	**Iterator is unidirectional, has 3 methods- hasNext();next();remove();
	**ListIterator is bidirectional, It has hasPrevious() and previous(), nextIndex(),previousIndex() methods as well

		List interface has 2 forms of list iterator , the one with the int argument will point the iterator from the integer index passed, the one without the argument will start the iterator from the begining of the list.
			
			Algorithm           ArrayList   LinkedList
			seek front            O(1)         O(1)
			seek back             O(1)         O(1)
			seek to index         O(1)         O(N)
			insert at front       O(N)         O(1)
			insert at back        O(1)         O(1)
			insert after an item  O(N)         O(1)
**Set Collection

		Duplicates are not allowed, It has only those methods from collection interface

		HashSet -Stores elements in hashtable, insertion order is not maintained(performance is good)
		TreeSet- Stores elements in red-black tree,insertion order is not maintained,It is a sorted set, It is a implementation of
		set Interface->Sortedset Interface->Navigable Interface
		LinkedHashSet- elements stored in hashtable, insertion order is maintaned

	HashSet Internally uses Hash map to insert the data 

eg in the documentation

		public boolean add(E e) {
  		 return map.put(e, PRESENT)==null;
		}
	Now as you can see that whenever we create a HashSet, it internally creates a HashMap and if we insert an element into this HashSet using add() method, it actually calls put() method on internally created HashMap object with element you have specified as it’s key and constant Object called “PRESENT” as it’s value. 	So we can say that a Set achieves uniqueness internally through HashMap and when we call put(Key, Value) method, it returns the previous value associated with key, or null if there was no mapping for key. So in add() method we check the return value of map.put(key, value) method with null value.
	
	As LinkedHashSet extends HashSet, so it internally calls constructors of HashSet using super(). Similarly creating an object of TreeSet class internally creates object of Navigable Map as backing map.

			to get the value from hashSet , the iterator method will return
			public Iterator<E> iterator() {
		        return map.keySet().iterator();
		    }

**Queue
		It is used to hold the elements before processing, It has additional methods like

				public interface Queue<E> extends Collection<E> {
				    E element();
				    boolean offer(E e);
				    E peek();
				    E poll();
				    E remove();
				}

		Each Queue method exists in two forms: 
		(1) one throws an exception if the operation fails.
		(2) the other returns a special value if the operation fails (either null or false, depending on the operation). The regular structure of the interface is illustrated in the following table.

				Queue Interface Structure

				Type of Operation	Throws exception	Returns special value
				Insert				add(e)				offer(e)
				Remove				remove()			poll()
				Examine				element()			peek()


	The add method, which Queue inherits from Collection, inserts an element unless it would violate the queue's capacity restrictions, in which case it throws IllegalStateException. The offer method, which is intended solely for use on bounded queues, differs from add only in that it indicates failure to insert an element by returning false.

	The remove and poll methods differ in their behavior only when the queue is empty. Under these circumstances, remove throws NoSuchElementException, while poll returns null.
	
	The element and peek methods return, but do not remove, the head of the queue.
	 If the queue is empty, element throws NoSuchElementException, while peek returns null.

	Queue implementations generally do not allow insertion of null elements. The LinkedList implementation, which was retrofitted to implement Queue, is an exception. For historical reasons, it permits null elements, but you should refrain from taking advantage of this, because null is used as a special return value by the poll and peek methods.

**Dequeue Is a linear collection of elements which supports adding and removal of elements in both the ends.
			It implememnts both stack and queue
				 ArrayDeque and LinkedList implement the Deque interface.

Note that the Deque interface can be used both as last-in-first-out stacks and first-in-first-out queues

			Deque Methods

			Type of Operation	First Element (Beginning of the Deque instance)		Last Element (End of the Deque instance)
			Insert				addFirst(e)											offerFirst(e)
								addLast(e)											offerLast(e)
												
			Remove				removeFirst()										removeLast()
								pollFirst()											pollLast()
											
			Examine				getFirst()											peekFirst()
								getLast()											peekLast()
								

A List is an ordered list of objects, where the same object may well appear more than once.
For example: [1, 7, 1, 3, 1, 1, 1, 5]. It makes sense to talk about the "third element" in a list. You can add an element anywhere in the list, change an element anywhere in the list, or remove an element from any position in the list.

A Queue is also ordered, but you'll only ever touch elements at one end. All elements get inserted at the "end" and removed from the "beginning" (or head) of the queue. You can find out how many elements are in the queue, but you can't find out what, say, the "third" element is. You'll see it when you get there.

A set is not ordered and cannot contain duplicates. You again can't ask for the "third" element or even the "first" element, since they are not in any particular order. You can add or remove elements, and you can find out if a certain element exists (e.g., "is 7 in this set?").

 ** Map provides
        To change the value use entrySet
        for(Map.Entry<Integer, String> i:m.entrySet()){
			i.setValue("Shimuli");
			}

        To remove the value use iterator

        Iterator itr1=m.keySet().iterator();
		while(itr1.hasNext()){
			
			itr.remove();
		}

		HashMap-Insertion order is not maintained,they are not synchronized
		Linked HashMap -Insertion order is maintained,they are not synchronized

		TreeMap is a sorted Map

InnerWorking of HashMap

	A hash collision in Java occurs when two or more keys have the same hash code and are stored in the same bucket

	HashMap uses a technique called hashing,If 2 objects are equal then they must have same hashcode
	Every object will have a hascode method which gives the hashcode of that object eg 231245 ,hashcode is a set of integer numbers.

	HasMap internally has a array of Node (each Node is a linked list)
	Node will have ie Node<k,v> will have

				int hashcode;
				 key;
		 		value;
				 Node<k,v> next;

	the lenght of the array is by default 16(index will be 0-15)
	When we try to insert a value to hashmap using put method, the hashcode of the key will be calculated and
	uisng the formula

		ie index=hashcode & (n-1) (& means modulus operation and n=16)

	whatever index we get we will insert the keyvalue pair in that node.If there are 2 keys with the same index then there will be hash colission
	Then we will check if both the key are same or equal
	if they are different then
		the first inserted record in that node, the  "next" poniter will be pointing to this new record.
	else if the keys are same
		if will replace the first record with the new record

HashMap will allow us to store a "Null" key, "Null" has a hashcode =0 so index of null key will be always 0

To get the value of the key we use the same index calculation and once we get the index we compare the hashcode value stored in the index with the hashcode of the Key value and the string key will also be compared using equals method. If both will match then the particular key will be retuned

In java 8
 If the number of duplicated index reaches more than the threshold ie TreeIFY_Threshold=8 then node switches from a linked list to a balanced tree  or binary tree to improve the performance

 Balanced tree means the heavier hashcode will be moved to the right side of the tree and the lighter one will be moved to the left.
 If the hascodes are equal then we compare the keys

 A binary search tree is a * sorted binary tree, where value of a node is greater than or equal to its * left the child and less than or equal to its right child.

 Read bst-https://www.youtube.com/watch?v=81PpYQ0AN_w


 SynchronizedHashMap vs ConcurrentHashMap -Both are used to achieve thread safe


 *SynchronizedHashMap maintains the lock at object level , to perform put or get we need to acquire the lock

 *ConcurrentHashMap mainitains the lock at bucket level read operation doesn't require a lock. So any number of threads can perform a get operation on it.If thread1 wants to perform put operation in segment 2 and thread2 wants to perform put operation on segment 4 then it is allowed here

	when to use
	We should favor Collections.synchronizedMap() when data consistency is of utmost importance, and we should choose ConcurrentHashMap for performance-critical applications where there are far more write operations 	than there are read operations.

	This is because the Collections.synchronizedMap() requires each thread to acquire a lock on the entire object for both read/write operations. By comparison, the ConcurrentHashMap allows threads to acquire locks 	on separate segments of the collection, and make modifications at the same time

Difference btw HashMap and HashTable

Hashmap is not thread safe and it is not synchronized
HashTable is threads safe and it is synchnonized

HashMap is fast
HashTable is slow

HashMap can allow one null key
HashTable does not allow null key

In hasMap and hashTable the insertion hashMap is not fixed, but in linked HashMap the insertion order is fixed.

ConcurrentHashMap vs Hashtable vs Synchronized Map- All the 3 are threadSafe

The only difference between Hashtable and Synchronized Map is that later is not a legacy and you can wrap any Map to create it's synchronized version by using Collections.synchronizedMap() method.

Read more: https://javarevisited.blogspot.com/2011/04/difference-between-concurrenthashmap.html#ixzz5yjFPtYkJ

HasSet vs HashMap
HashSet allows one null value HashMap allows one null key and any number of null values
HaShSet is a implemention of Set Interface, HashMap is a implemention of Map Interface
HashSet we have add , HaspMap we have put

TreeHashMap is a sorted HashMap and it does not allow null keys.

** TreeMap
	Some of the important points to remember about TreeMap in java are;

	Apart from implementing Map interface, Java TreeMap also implements NavigableMap and indirectly implements SortedMap interface. TreeMap also extends AbstractMap class.

	TreeMap entries are sorted in the natural ordering of its keys. It also provides a constructor to provide Comparator to be used for ordering. So if you are using any class as key, make sure it’s implementing Comparable interface for natural ordering.

	Java TreeMap implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations.

	TreeMap is not synchronized and hence not thread-safe. For multithreaded environments, you can get a wrapped synchronized using Collections.synchronizedSortedMap method.

	TreeMap methods to get keyset and values return Iterator that are fail-fast in nature, so any concurrent modification will throw ConcurrentModificationException.
	
	TreeMap in java doesn’t allow null keys, however you can have multiple null values associated with different keys.

 ***Cursors
 	To get individual values from collection we have

 		1.Enumeration
 		2.Iteration
 		3.ListIteration

 	Utility classes which have some utility methods for collection

 		1.Collections
 		2.Arrays

Advantages of Data Structure
	Reusability
	Efficiency
	Abstraction

    **Stack-LIFO
     Stack is a linear list in which insertion and deletions are allowed only at one end, called top.
	Stack is a abstract datatype. It uses LIFO-Last In First Out,
	It has features like 
	push - to add a element
	pop- to delete a element
	peek-to view a element
	In stack we have only one entry point
	If we are adding more value to the fixed size stack then we get overflow error
	Underflow error is when you try to get value from a empty stack

**Queue-FIFO
	Queue is a linear list in which elements can be inserted only at one end called rear and deleted only at the other end called front.
	Queue used FIFO and it has enqueue for insertion and dequeue for deletion.
	We need to create enque,dequeue isEmpty,isFull,getSize methods with normal logic.

**Linked List
	LinkedList is an implementation of both a queue and a stack

	Poll vs Pop
	Poll will return null if the list is empty and Poll is also used to remove the head element.
	Pop will throw java.util.NoSuchElementException and Pop is used to remove and return the head element.
	

	Other methods are 
	peek()
	peekFirst()
	peekLast()

	3 types of linkedList
	1.Single linked list
	2.doublylinkeedList- It has a link to previous as well as next node
	3.CircularLinkedList- The nodes are connected to form a circle, First node and last node are connected.

Array vs LinkedList

Array size if fixed, LinkedList size is dynamic.
Array is faster for adding,deleting, Linked list is slower for these operations.
Array consumes more memory, In linked List the memory can be redumped to heap.

*Tree
	
	This data structure uses a concept of Node

	TopNode is root node
	lines which connect each node is edge
	Nodes which donot have any child are called Leaf Node

**Binary Tree

	Binary tree is a Tree which does not have more than 2 nodes, all the nodes can have 0,1 not more than 2 node

	Types in Binary Tree

	1.Strict Binary Tree- Either 0 or 2 nodes or childrens
	2.Full Binary Tree - Where all the childrens are on same level( they will have same right and left nodes)
	3.Complete Binary tree where the level of child nodes are l and l-1

	Depth- Distance btw Root Node
	Height-Height till last child node

	Height of the tree = height of root node




Read more: https://javarevisited.blogspot.com/2015/10/how-to-implement-binary-search-tree-in-java-example.html#ixzz5vtwsQjZh

**ArrayList vs Linked List

	ArrayList uses dynamice resiazable array, ArrayList is faster to retrival of data
	LinkedList uses doubly linked List, LinkedList is faster for manupulation

	Manipulation with ArrayList is slow because it internally uses an array. If any element is removed from the array, all the other elements are shifted in memory.
	Manipulation with LinkedList is faster than ArrayList because it uses a doubly linked list, so no bit shifting is required in memory.

Seralization and Deserialization

	Is the process of converting the object into byte array so that it can be transferred into a file or over a network

		Using FileOutPutStream for file and ObjectOutPutStream for Object we can achieve this -Serializzation


		Is the process of converting the Byte array back to java object so that it can be transferred into a file or over a network

		Using FileInputPutStream for file and ObjectInputPutStream for Object we can achieve this -Serializzation


	Transcient is a keyword which is only used for variables
	Transcient will not serialize the object value it will send the default value of the field

	transcient  int i=10;  //o/p will be 0

	transcient final int i=10;  //o/p will be 10 ( because for final variables value will be assigned at compile time)
		if final variable is initilized inside constructor then transcient will work, op will be 0

	transcient static int i=10;  //o/p will be 10 (only non static variables participate in serialization)

	for serialzation the order in which we serialize , the same order we have to deserialze. 
	if we do not know the order then we can use instanceOf operator for find the instance

	*Object Graph- When we serialze a object , set of all objects which are reachable to that object will be serialized

	while adding customized Serialization we have to implement
	private void WriteObject(OOS oos);
	private void readObject(OIS ois); if we dont implement these methods then jvm will use the defaut serialisation methods
	*these 2 methods are called automatically by jvm hence they are called call back methods

	continue from here https://www.youtube.com/watch?v=p-98X_1mMIY



Design Patterns

1) Creational Pattern
	Factory Method Pattern
	Abstract Factory Pattern
	Singleton Pattern
	Prototype Pattern
	Builder Pattern
	Object Pool Pattern

2) Structural Pattern
	Adapter Pattern
	Bridge Pattern
	Composite Pattern
	Decorator Pattern
	Facade Pattern
	Flyweight Pattern
	proxy Pattern

3) Behavioral Pattern
	Chain of Responsibility
	Command Pattern
	Interpreter Pattern
	Iterator Pattern
	Mediator Pattern
	Memento Pattern
	Observer Pattern
	State Pattern
	Strategy Pattern
	Template Pattern

1.Factory Method Pattern

	It is a design pattern where we are providing the interface to create a object and the subclass has to pass the type and depending on the type we are creating the object

	The factory method pattern loosens the coupling code by separating our Product‘s construction code from the code that uses this Product

	The Factory Method Pattern is also known as Virtual Constructor.
	It promotes polymorphism you can create diffferent objects in runtime

									class GetPlanFactory{  
			      
			   //use getPlan method to get object of type Plan   
			       public Plan getPlan(String planType){  
			            if(planType == null){  
			             return null;  
			            }  
			          if(planType.equalsIgnoreCase("DOMESTICPLAN")) {  
			                 return new DomesticPlan();  
			               }   
			           else if(planType.equalsIgnoreCase("COMMERCIALPLAN")){  
			                return new CommercialPlan();  
			            }   
			          else if(planType.equalsIgnoreCase("INSTITUTIONALPLAN")) {  
			                return new InstitutionalPlan();  
			          }  
			      return null;  
			   }  



2.Abstract Factory Pattern
		define an interface or abstract class for creating families of related (or dependent) objects but without specifying their concrete sub-classes

		

				interface CarFactory {
				    Car createCar();
				    CarSpecification createSpecification();
				}

3.ProtoType Design Pattern

	cloning of an existing object instead of creating new one and can also be customized as per the requirement.

		EmployeeRecord e1=new EmployeeRecord(eid,ename,edesignation,esalary,eaddress);  
          
        e1.showRecord();  
        System.out.println("\n");  
        EmployeeRecord e2=(EmployeeRecord) e1.getClone();  //IN get clone we are creating a object
        e2.showRecord();  

4.Builder Design Pattern
	construct a complex object from simple objects using step-by-step approach

	Create a tank Interface
	create a fuel Interface

	create a car interfcae which extends both tank and fuel

	create a implementation nanocar extending car Interface

Structural DesignPattern


5.Adopter Design pattern: It is a structural design pattern where 2 unrelated interfaces can work together and the object which joins these 2 are called Adapter.

	Adapter makes things work after they're designed; Bridge makes them work before they are

	Effectively, the Adapter pattern is useful when you have existing code, be it third party, or in-house, but out of your control, or otherwise not changeable to quite meet the interface you need it to.

6.Brdige Design Pattern
It is a structural Design Pattern where we seperate the abstraction hierarcy and implementation hieracy into 2 different layers so that chaneg in one layer will not effect the other layer

	The Bridge pattern is something you implement up front - if you know you have two orthogonal hierarchies, it provides a way to decouple the interface and the implementation in such a way that you don't get an insane number of classes. Let's say you have:

	MemoryMappedFile and DirectReadFile types of file objects. Let's say you want to be able to read files from various sources (Maybe Linux vs. Windows implementations, etc.). Bridge helps you avoid winding up with:

	MemoryMappedWindowsFile MemoryMappedLinuxFile DirectReadWindowsFile DirectReadLinuxFile

7.Facade Design patter is a pattern where the complexities of the system is hidden and the client is provided with the interface to access the system

	Facade hides the complexities of the system and provides an interface to the client from where the client can access the system.

public class Inventory {
public String checkInventory(String OrderId) {
    return "Inventory checked";
}
}

public class Payment {
public String deductPayment(String orderID) {
    return "Payment deducted successfully";
}
}


public class OrderFacade {
private Payment pymt = new Payment();
private Inventory inventry = new Inventory();

public void placeOrder(String orderId) {
    String step1 = inventry.checkInventory(orderId);
    String step2 = pymt.deductPayment(orderId);
    System.out
            .println("Following steps completed:" + step1
                    + " & " + step2);
   }
}

public class Client {
       public static void main(String args[]){
         OrderFacade orderFacade = new OrderFacade();
         orderFacade.placeOrder("OR123456");
         System.out.println("Order processing completed");
       }
  }

8.Flyweight Design Pattern
In this design pattern reuses ing the already ceated objects and resuing them and create new object when no match is found

9.Chain of Responsibility
A request can be handled by a chain of objects , The request is not coupled to a single object rather than a chain
eg catchblock

Observer Design pattern
	An Observer Pattern says that "just define a one-to-one dependency so that when one object changes state, all its dependents are notified and updated automatically".

Command Design pattern

	A Command Pattern says that "encapsulate a request under an object as a command and pass it to invoker object. Invoker object looks for the appropriate object which can handle this command and pass the command 	to the corresponding object and that object executes the command".

	Advantage of command pattern
	It separates the object that invokes the operation from the object that actually performs the operation.
	It makes easy to add new commands, because existing classes remain unchanged.

Proxy Design pattern
You need to update
	It provides the protection to the original object from the outside world.

**Light weight process (Threads) vs Heavyweight process

	Light weight process will have multiple thread  sharing the same address space.
	
	Heavy weight Process- There will be different process created to work parallely and each process has its own address space.

Process and Threads


	Process has its own self contained execution environment,it will have its own memory space

	Threads are light weight processes which requires few resource for creation compared to process,

		Threads exist within a process, every process will have alreast one thread.

		But from programers point of view we create one thread called main thread which has the ability to create multiple threads.


**Difference between Thread and Process

	A Process is a OS level task or service 
	A thread runs inside a process, usually process have their own address space where as threads use shared address space


Threads
Threads is a unit of a process
They are used for parallel execution and very java program creates at least one thread [ main() thread ].

Threads can be implemented in 2 ways. 
1. By extending Thread class
		
			public class MyThread extends Thread {
				   public void run(){  
				    System.out.println("thread is running...");  
				  } 
				   public static void main(String[] args) {
				     MyThread obj = new MyThread();
				     obj.start();
					}

			Since multiple inheritance is not possible we can use a Runnable interface to create a thread
		** 1000 millisecond is 1 second

2. By implementing Runnable Interface

			public class MyThread implements Runnable {
  				 public void run(){  
				     System.out.println("thread is running..");  
				   }  
				   public static void main(String[] args) {
				     Thread t = new Thread(new MyThread());
				     t.start();
				}

**Extends Thread class vs Implements Runnable Interface?

	Extending the Thread class will make your class unable to extend other classes, because of the single inheritance feature in  JAVA. However, this will give you a simpler code structure. If you implement Runnable, you can gain better object-oriented design and consistency and also avoid the single inheritance problems.
	Creating an implementation of Runnable and passing it to the Thread class utilizes composition and not inheritance – which is more flexible


**Thread Life cycle in Java
	The start method creates the system resources, necessary to run the thread, schedules the thread to run, and calls the thread’s run method.

	A thread becomes “Not Runnable” when one of these events occurs:
	If sleep method is invoked.
	The thread calls the wait method.
	The thread is blocking on I/O.
	
	A thread dies naturally when the run method exits.

**Thread.join()-The join() method waits for a thread to die

	Why we use join() method?
	In normal circumstances we generally have more than one thread, thread scheduler schedules the threads, which does not guarantee the order of execution of threads.
For example lets have a look at the following code:
			

		Thread th1 = new Thread(new MyClass(), "th1");
      Thread th2 = new Thread(new MyClass(), "th2");
      Thread th3 = new Thread(new MyClass(), "th3");
         
      // Start first thread immediately
      th1.start();
         
      /* Start second thread(th2) once first thread(th1) 
       * is dead
       */
      try {
          th1.join();
      } catch (InterruptedException ie) {
          ie.printStackTrace();
        }
      th2.start();
         
      /* Start third thread(th3) once second thread(th2) 
       * is dead
       */
      try {
          th2.join();
      } catch (InterruptedException ie) {
           ie.printStackTrace();
        }
      th3.start();
         
      // Displaying a message once third thread is dead
      try {
          th3.join();
      } catch (InterruptedException ie) {
            ie.printStackTrace();
        }  
      System.out.println("All three threads have finished execution");
   }
}

**Why don’t we call run() method directly, why call start() method?

	If we call just run method then it will run just like a normal method and we will be not be able to take the advantage of multithreading
	If we call run method through start method a seperate new Thread gets allocated for its execution and all these threads would run simultaneously

**Can we start a thread twice in Java? 
	The answer is no, once a thread is started, it can never be started again. Doing so will throw an IllegalThreadStateException.

	method isAlive(): Determine if a thread is still running.

Interrupt-
Interrupt is a polite way of asking a thread to stop because we cannot force the thread to stop suddenly because it might be in middle of some operation or some db connections might be open.
		Interrupt tells the thread to stop what it is doing now and do something else.
		
		If main thread suppose T1 has started one more long running process P1 and if you want to stop this thread then there is no cancel mechanism in thread.
		So we are using Interrupts.

Since P1 is running in a seperate thread how will it know if someone can called the interrupt method?

	when we invoke thread.interrupt(); from the main thread,Interrupt flag will be set.
	In thread implementation of P1 we have to monitor if the interrupt has been invoked by checking this flag (isInterrupted).
If interrupt is received then we can either return or throw interrupt exception.
Interrupt exception is thrown because other wise we will not know if the thread has exited by the normal flow or by interrupt.

	Use Thread.interrupted() to reset the flag or else the flag will always be true.	
	When a thread checks for an interrupt by invoking the static method Thread.interrupted, interrupt status is cleared. 

	The non-static isInterrupted method, which is used by one thread to query the interrupt status 	of another, does not change the interrupt status flag.

	Other than long process . JVM throws interrupt in 3 places
	sleep
	wait
	join

		For methods which thrown InterruptException like sleep and wait, when we use t.interrupt()
		If there is Thread.sleep or wait method then InterruptedException is thrown and execution is returned from the run method

		If a thread goes a long time without calling the method like sleep(which throws Interrupt Exception), then calling Thread.interrupted will tell if a thread has received a interrupt.

		Internally there ia a flag called interrupt status flag which will be set when a thread is interrupted,
		Thread.interrupted() will return true if the thread is interrupted and it will clear the interrupt status flag

		(if we call static method Thread.interrupted() twice den the second call will return false because the flag will be cleared by the first call)

		There is a non static method called isInterrupted which will only check if the thread is interrupted, it will not change the Interrupt flag.

	*Any method that exits by throwing an InterruptedException clears interrupt status when it does so

for clear understanding of interrupt https://www.youtube.com/watch?v=-7ZB-jpaPPo

t1.join() method will make other threads to stops until the current thread completes the execution.(call only after starting the thread or else it wont work)

Join method will only throw interrupted exception if the current thread that is calling the t.join() gets interrupted

			Thread t=new Thread(new ThreadM());
		
				t.start();
				t.interrupt()// will not throw Interrupted Exception
				Thread.currentThread().interrupt()//will throw the exception
					t.join()


isAlive() is used to check whether a thread is alive or not. after join method isAlive will return false.

t1.getPriority() will give the priority of thread, the range of priority ranges from 1 to 10.
		We can also use inbuilt constants of thread for fixing priority
		eg t1.setPriority(Thread.MIN_PRIORITY);//this is bulit in constant
		Setting priority will only hint the OS but if will not guarentee the execution, If there is any constariant in the cpu memory den the thread with higher priority will run first.

t1.setName("thejas")- will set the name of thread as thejas

		Thread t2=new Thread(()->{ 
					 for(int i=0;i<=5;i++){
						 System.out.println("Apple of i"+i);
					 }
				});
				t2.start();

Happens before relationship-Memory writes and other changes from one statement will be visible to another statement.

Synchronized- can be used only on methods or code block

	adding "synchronized" will make a block or method thread safe, multiple threads cannot acces the same resource at a time

	Constructors are not synchronized, it will give a syntax error.The JVM ensures that only one thread can invoke a constructor call at a given point in time.

Every object has a intrinsic lock associated with it , if any thread wants any exclusive access for a object then it needs to acquire the lock for the object.

	Intrinsic lock is also called as monitor

	If one thread has a intrinsic lock another thread cannot have the lock

	When we use synchronized keyword will make sure that the method or statement will acquire the lock and while returning it will release the lock, even during run time exception the lock will be returned.

	When a thread releases an intrinsic lock, a happens-before relationship is established between that action and any subsequent acquisition of the same lock.

You might wonder what happens when a static synchronized method is invoked, since a static method is associated with a class, not an object. In this case, the thread acquires the intrinsic lock for the Class object associated with the class. Thus access to class's static fields is controlled by a lock that's distinct from the lock for any instance of the class.
	
Reentratnt lock-https://www.youtube.com/watch?v=ahBC69_iyk4

	Suppose 4 threads are trying to book a same seat in the movie theater then only 1 thread must be allowed , We can achieven this using Reentratnt lock. 
	When 1 thread has the lock all the other threads go to waiting state and once the unlock method is called by the thread then again all the waiting threads becomes runnable and again they try to acquire the lock 	and the process repeats

	Unlike synchronised block we can use Reentratnt.lock(); in 1 method  and Reentratnt.unlock(); in another method
	
Reentrant Synchronization-  thread can acquire a lock that it already owns. Allowing a thread to acquire the same lock more than once enables reentrant synchronization.This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock. Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block.
	
	Synchronized block implicit and Re entrant lock is explicit (Implicit means done by the JVM or the tool , not the Programmer)
	1) Another significant difference between ReentrantLock and synchronized keyword is fairness. synchronized keyword doesn't support fairness. Any thread can acquire lock once released, no preference can be specified, on the other hand you can make ReentrantLock fair by specifying fairness property, while creating instance of ReentrantLock. Fairness property provides lock to longest waiting thread, in case of conjenction.

	2) Second difference between synchronized and Reentrant lock is tryLock() method. ReentrantLock provides convenient tryLock() method, which acquires lock only 	if its available or not held by any other thread. This reduce blocking of thread waiting for lock in Java application.

	3) One more worth noting difference between ReentrantLock and synchronized keyword in Java is, ability to interrupt Thread while waiting for Lock. In case of synchronized keyword, a thread can be blocked waiting for lock, for an indefinite period of time and there was no way to control that. ReentrantLock 	provides a method called lockInterruptibly(), which can be used to interrupt thread when it is waiting for lock. Similarly tryLock() with timeout can be used to timeout if lock is not available in certain time period.

	4) ReentrantLock also provides convenient method to get List of all threads waiting for lock.

For static methods there will be class level intrinsic lock(test.class)
For Non static methods there will be object level lock(this)

When a thread is acessing a synchronized method, other threads cannot access other non static methods of that object, but they can access the static synchronized methods because for static methods it is class level lock.

Class level locking-If there are 100 instance of a class then any thread that is acessing a static synchronized method then other Threads cannot access the static synchronized methods of that class, but can access non static Synchronized methods.

If we use synchronize as a statement then  other threads can use other synchronized methods only the statments within the block will be synchronized

		
There are two important concepts in multithreading environment:

Atomicity and Visibility

The volatile keyword eradicates visibility problems, but it does not deal with atomicity. volatile will prevent the compiler from reordering instructions which involve a write and a subsequent read of a volatile variable; e.g. k++. Here, k++ is not a single machine instruction, but three:

copy the value to a register;
increment the value;
place it back.
So, even if you declare a variable as volatile, this will not make this operation atomic; this means another thread can see a intermediate result which is a stale or unwanted value for the other thread.

	As Trying as indicated, volatile deals only with visibility.

	Consider this snippet in a concurrent environment:

	boolean isStopped = false;
	    :
	    :

	    while (!isStopped) {
	        // do some kind of work
	    }
	The idea here is that some thread could change the value of isStopped from false to true in order to indicate to the subsequent loop that it is time to stop looping.

	Intuitively, there is no problem. Logically if another thread makes isStopped equal to true, then the loop must terminate. The reality is that the loop will likely never terminate even if another thread makes isStopped equal to true.

	The reason for this is not intuitive, but consider that modern processors have multiple cores and that each core has multiple registers and multiple levels of cache memory that are not accessible to other processors. In other words, values that are cached in one processor's local memory are not visisble to threads executing on a different processor. Herein lies one of the central problems with concurrency: visibility.

	The Java Memory Model makes no guarantees whatsoever about when changes that are made to a variable in one thread may become visible to other threads. In order to guarantee that updates are visisble as soon as they are made, you must synchronize.

	The volatile keyword is a weak form of synchronization. While it does nothing for mutual exclusion or atomicity, it does provide a guarantee that changes made to a variable in one thread will become visible to other threads as soon as it is made. Because individual reads and writes to variables that are not 8-bytes are atomic in Java, declaring variables volatile provides an easy mechanism for providing visibility in situations where there are no other atomicity or mutual exclusion requirements.

On the other hand, AtomicInteger, AtomicReference are based on the Compare and swap instruction. 
	CAS has three operands: a memory location V on which to operate, the expected old value A, and the new value B. CAS atomically updates V to the new value B, but only if the value in V matches the expected old value A; otherwise, it does nothing. In either case, it returns the value currently in V. 
	The compareAndSet() methods of AtomicInteger and AtomicReference take advantage of this functionality, if it is supported by the underlying processor; if it is not, then the JVM implements it via spin lock.


Atomic Operations https://www.youtube.com/watch?v=WH5UvQJizH0&list=PLhfHPmPYPPRk6yMrcbfafFGSbE2EPK_A6&index=1
	These are the operations which cannot stop in the middle, either they suceed or they fail,there is no in between.

	Read and write for reference variables and for primitive types (other than float and long) are atomic

	Atomic operations will protect from thread interferance but memory inconsistency is still possible 

	If you use volatile keyword then all variables including long and float

	Volatile established happens before relationship for all the read operation for the variables also when the thread sees the volatile keyword, it will not just see the latest value, it will also see the side effect that led to the value change.
	
	 the volatile modifier guarantees that any thread that reads a field will see the most recently written value

	Using Atomis operation is more efficient then acessing the variables in sychronized code but we need to take special care to avoid memory inconsitency,Whether the extra effort is worthwhile depends on the size and complexity of the application

For Synchronization we use Atmoic Variable
eg value++
AtomicInteger value=new AtomicINteger(1);
		value.incrementAndGet();


		class Test  
		{  
		static int var=5;  
		}  
		In the above example, assume that two threads are working on the same class. Both threads run on different processors where each thread has its local copy of var. If any thread modifies its value, the change will not reflect in the original one in the main memory. It leads to data inconsistency because the other thread is not aware of the modified value.

		class Test  
		{  
		static volatile int var =5;  
		}  

		In the above example, static variables are class members that are shared among all objects. There is only one copy in the main memory. The value of a volatile variable will never be stored in the cache. All read and write will be done from and to the main memory.
		


Volatile can be used for flags
AtomicInteger can use used for Counters

Dead Lock,Starvation and Live Lock

		Dead Lock is a situation where One thread(A) is waiting for another thread(B) to complete but that thread(B) is waiting for the thread (A) to complete.
			In Dead Lock both the threads will be blocked because of each other.

				For example, consider two processes, P1 and P2, and two resources, R1 and R2. Suppose that each process needs access to both resources to perform part of its function. Then it is possible to have the following situation: the OS assigns R1 to P2, and R2 to P1. Each process is waiting for one of the two resources. Neither will release the resource that it already owns until it has acquired the other resource and performed the function requiring both resources. The two processes are deadlocked


		Starvation-Sitation in which a thread is not able to make progress because other threads are consuming the resoures required for this thread to complete.


		Live Lock is a situation in which threads are not blocked but they are busy responding to each other or changing their states because of change in other thread, they are not doing anything useful .


Guarded Blocks
Threads often have to coordinate their actions. The most common coordination idiom is the guarded block. Such a block begins by polling a condition that must be true before the block can proceed. There are a number of steps to follow in order to do this correctly.

Suppose, for example guardedJoy is a method that must not proceed until a shared variable joy has been set by another thread. Such a method could, in theory, simply loop until the condition is satisfied, but that loop is wasteful, since it executes continuously while waiting.

public void guardedJoy() {
    // Simple loop guard. Wastes
    // processor time. Don't do this!
    while(!joy) {}
    System.out.println("Joy has been achieved!");
}

A more efficient guard invokes Object.wait to suspend the current thread. The invocation of wait does not return until another thread has issued a notification that some special event may have occurred — though not necessarily the event this thread is waiting for:

public synchronized void guardedJoy() {
    // This guard only loops once for each special event, which may not
    // be the event we're waiting for.
    while(!joy) {
        try {
            wait();
        } catch (InterruptedException e) {}
    }
    System.out.println("Joy and efficiency have been achieved!");
}

	Wait will suspend the thread untill another thread has issued a notification that some special event has ocured, it might not be a notificatio which this thread is waiting, now the thread will execute one to check  the condition.

Always invoke wait inside a loop that tests for the condition being waited for. Don't assume that the interrupt was for the particular condition you were waiting for, or that the condition is still true

Like many methods that suspend execution, wait can throw InterruptedException. In this example, we can just ignore that exception — we only care about the value of joy.

Why is this version of guardedJoy synchronized? 


	Let's illustrate what issues we would run into if wait() could be called outside of a synchronized block with a concrete example.

	Suppose we were to implement a blocking queue (I know, there is already one in the API :)

	A first attempt (without synchronization) could look something along the lines below

				class BlockingQueue {
				    Queue<String> buffer = new LinkedList<String>();
				    
				    public void give(String data) {
				        buffer.add(data);
				        notify();                   // Since someone may be waiting in take!
				    }
				    
				    public String take() throws InterruptedException {
				        while (buffer.isEmpty())    // don't use "if" due to spurious wakeups.
				            wait();
				        return buffer.remove();
				    }
				}
		This is what could potentially happen:

		A consumer thread calls take() and sees that the buffer.isEmpty().

		Before the consumer thread goes on to call wait(), a producer thread comes along and invokes a full give(), that is, buffer.add(data); notify();

		The consumer thread will now call wait() (and miss the notify() that was just called).

		If unlucky, the producer thread won't produce more give() as a result of the fact that the consumer thread never wakes up, and we have a dead-lock.

		Once you understand the issue, the solution is obvious: Use synchronized to make sure notify is never called between isEmpty and wait.

		This synchronization issue turns out to be universal. As Michael Borgwardt points out, wait/notify is all about communication between threads, so without synchronization you'll always end up with a race condition similar to the one described above. This is why the "only wait inside synchronized" rule is enforced.

A paragraph from the link posted by @Willie summarizes it quite well:

	You need an absolute guarantee that the waiter and the notifier agree about the state of the predicate. The waiter checks the state of the predicate at some point slightly BEFORE it goes to sleep, but it depends for correctness on the predicate being true WHEN it goes to sleep. There's a period of vulnerability between those two events, which can break the program.

The predicate that the producer and consumer need to agree upon is in the above example buffer.isEmpty(). And the agreement is resolved by ensuring that the wait and notify are performed in synchronized blocks.
			
	
whenever we use wait() and notify() inside the method,the method needs to be synchronized because we wait() for certain condition to be satisfied by the other thread and wait is useful only wiht Notify so for both to work we need the threads to be synchronised other wise it will be a race condition.

Wait can also throw InterruptedException
when wait is invoked it will release the lock and suspend exectution.At some future time, another thread will acquire the same lock and invoke Object.notifyAll, informing all threads waiting on that lock that something important has happened:

There is a second notification method, notify, which wakes up a single thread

sleep(100) vs t1.wait()

			wait() method releases the lock   -  sleep() method doesn't release the lock.
			wait is the method of Object class -  sleep is the method of Thread class
			wait is non static Method 			- sleep is static method


			
**wait() and notify()
wait() will causes the current thread to wait untill another thread invokes notify() or notifyAll() method
notify() wakes up a single thread that is waiting to accept to use the resource (should be the first thread which used wait())
notifyAll() will wake up that are waiting to access the resource

Immutable design

		Dont provide setters which modify the fields
		Create all fields private and final. (By making fields private and final, you are making sure that no one will able to change the field value once an object is created)

		All fields are initialized using a constructor, so values can be assigned at the time of object creation.

		Don't allow subclasses to override methods. The simplest way to do this is to declare the class as final. A more sophisticated approach is to make the 	constructor private and construct instances in 	factory methods.

		If the instance fields include references to mutable objects, don't allow those objects to be changed:
		Don't provide methods that modify the mutable objects.
		Don't share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.

Threadpool
https://www.youtube.com/watch?v=6Oo-9Can3H8

If we want to run 1000 operations we dont have to create 1000 thread instances , instead we can use ThreadPool.
	ie ExecutorService service=Executors.newThreadPool(10); //here number 10 is the size of the thread pool
	In this way we can use 10 threads for our opreation

	For cpu intensive operations we can use the pool size = size of the core because 1 java thread= 1 os thread so maximim 4 threads can run at a time for the 4 core machine,
		In the runtime there is method to get the number of cores
	For I/O like database reads operations or http url , the threads will go for wait state so we can keep the thread pool size bit large
ThreadLocal
	The TheadLocal construct allows us to store data that will be accessible only by a specific thread.

	Let’s say that we want to have an Integer value that will be bundled with the specific thread:

	ThreadLocal<Integer> threadLocalValue = new ThreadLocal<>();
	threadLocalValue.set(1);
	Integer result = threadLocalValue.get();

As a result, when we call a get() method on the threadLocalValue, we’ll get an Integer value for the requesting thread:



Parallism means completing or doing a lot of work at once.
		To achieve Parellism in Java we have
		1.Thread
		2.Thread pool
			Thread Pool has
				a.ExecutorService 
				b.ForkJoinPool
				c.Custom Threadpool(eg:webservers)
		In all the above case we have to make sure our cpu has more that 1 core.

Concurrrency means when dealing with lot of things are once ie multiple threads are trying to access the same resource
	To achieven concurrency we have
	1.Synchronised
	2.Locks
	3.ConcurrentDataStructures
	4.Completable Future

** How to achieve Thread Safe

1. Using the stateless Implementation

				public class StateLess{

				public static int addValue(Integer value){
				value=value+1;
				return value;
				}
				}		
		In the above example
		The method neither relies on external state nor maintains state at all. Hence, it’s considered to be thread-safe and can be safely called by multiple threads at the same time.

		Therefore, stateless implementations are the simplest way to achieve thread-safety.


2.Making a class Immutable-
	The easiest way to create an immutable class in Java is by declaring all the fields private and final and not providing setters

			public class MyClass {
	   			private final int number;

	   			public MyClass(int number) {
	    		this.number = number;
	   			}

	   			public int getNumber() {
				   return number;
				   }

		}

3. Synchronized Method

			public synchronized void incrementCounter() {
		    counter += 1;
		}

		We’ve created a synchronized method by prefixing the method signature with the synchronized keyword.

		Since one thread at a time can access a synchronized method, one thread will execute the incrementCounter() method, and in turn, others will do the same. No overlapping execution will occur whatsoever.

Synchronized Collection

	We can make the collections also synchronized
	Collection<Integer> syncCollection = Collections.synchronizedCollection(new ArrayList<>());
	Thread thread1 = new Thread(() -> syncCollection.addAll(Arrays.asList(1, 2, 3, 4, 5, 6)));
	Thread thread2 = new Thread(() -> syncCollection.addAll(Arrays.asList(7, 8, 9, 10, 11, 12)));
	thread1.start();
	thread2.start();

MultiThreading
 Multithreading is main done to increase the execution speed, One thread will access one core so multi threads will access multiple cores in cpu

 2.Synchronous tasks
To take heap dum kill-3

 Thread dead lock- When the thread 1 is holding a resource lock of thread 2 and thread 2 is holding the resource lock of thread 1 then one it will be thread lock


 /*
     * This method request two locks, first String and then Integer
     */
    public void method1() {
        synchronized (String.class) {
            System.out.println("Aquired lock on String.class object");
            synchronized (Integer.class) {
                System.out.println("Aquired lock on Integer.class object");
            }
        }
    }
    /*
     * This method also requests same two lock but in exactly
     * Opposite order i.e. first Integer and then String. 
     * This creates potential deadlock, if one thread holds String lock
     * and other holds Integer lock and they wait for each other, forever.
     */
    public void method2() {
        synchronized (Integer.class) {
            System.out.println("Aquired lock on Integer.class object");
            synchronized (String.class) {
                System.out.println("Aquired lock on String.class object");
            }
        }
    }
}

solution is to maintain the order

 public void method1() {
        synchronized (Integer.class) {
            System.out.println("Aquired lock on Integer.class object");
            synchronized (String.class) {
                System.out.println("Aquired lock on String.class object");
            }
        }
    }
    public void method2() {
        synchronized (Integer.class) {
            System.out.println("Aquired lock on Integer.class object");
            synchronized (String.class) {
                System.out.println("Aquired lock on String.class object");
            }
        }
    }
}

Runnable vs collable

	A Callable needs to implement call() method while a Runnable needs to implement run() method.
	A Callable can return a value but a Runnable cannot.
	A Callable can throw checked exception but a Runnable cannot.
	A Callable can be used with Thread class and ExecutorService (there is a method invoke which takes Collable Object as parameter #invokeXXX(Collection<? extends Callable<T>> tasks) methods but a Runnable can be used only with Thread .


Advanced Thread Concepts

	1.Lock Objects
		Synchronized blocks use re entrant locks, this kind of lock is easy to use but has limitations.
		More sophisticated locking idioms are supported by the java.util.concurrent.locks package
		Similar to implicit locks, only one thread can own a lock object at a time,they also support wait/notify mechanism throught their associated condition mechanism.

		The biggest advantage of Lock objects over implicit locks is their ability to back out of an attempt to acquire a lock. The tryLock method backs out if the lock is not available immediately or before a timeout expires (if specified). The lockInterruptibly method backs out if another thread sends an interrupt before the lock is acquired.

	2.Executors
		For small applications there is a conectin between task being done by the new thread as defined by it's runnable object and the thread itself as defined by the Thread Object
		For bigger application, it makes sense to sepetate the thread management and creation from the rest of the application.
		Objects that encapsulates these functions are known as executors


		There are 3 interfaces for executors

		1.Executor Interface

				This has a method called execute whihc takes a runnable object of thread.

				you can replace

				(new Thread(r)).start();
				with

				e.execute(r);

**Inner Class

	1.The scope of a nested class is bounded by the scope of its enclosing class.NestedClass does not exist independently of class OuterClass.
	2.A nested class has access to the members, including private members, of the class in which it is nested. However, reverse is not true i.e. the enclosing class does not have access to the members of the nested class.
	3.A nested class is also a member of its enclosing class.
	
For inner class the class file will be created name will be A$B.class where A is the outer class and B is the inner class

There are 3 types 

	1.Non Static class
		To Acess the inner class variables we have to the following
	we have to create a outer class Instance and using that we have to access the inner class variables

		Outer o=new Outer();
		Outer.Inner u= o.new Inner();

		If we want to access the outer class non static variables then we dont have to create the objects of outer class

		public class InnerRun  {
		private int it=10;
		int j=20;
	
	
		public class Ulai{
		public void getUlai(){
			
		System.out.println(j+it);
		}
	}

		}


	2.Static Class
		**If we make the inner class static we dont need to create the object of the outer class,
		**Only Nested class can be static , the outer class cannot be static

		To Acess the non static variables inside a static class
		StringUnique.Inside u = new StringUnique.Inside();
		u.run();

** 	To acess the non static inner class , we have to create Object of the outer class
	To acess the  static inner class , we do not have to create object of outer class

	A static class cannot access non-static members of the Outer class. It can access only static members of Outer class.


	3.Anonymous Inner Classes

	**	Age oj1 = new Age() {
            @Override
            public void getAge() {
                System.out.print("Age is "+x);
            }
        };

	Age is a interface,
** Anonymous Objects are objects without reference
	new A().showEmployee();// This does not have a reference and hence it will not utilize the stack memory , it will use only heap

	Since anonymous objects dont have reference , they are eligible for garbage collection

---------------------------------Java Upgrades--------------------------------------------------------------------------------------------

**In java 8 

1.we can create methods in interface

	Inside interface you can define a method with a default keyword and for defining static methods we dont have to use default keyword
	eg:

	public interface employee{

	public Employee getEmployee();

	default Employee findEmployee(int employeeId){

	}
	}

	If there are 2 interfaces which have defined a same method in them then the implementing class shoudl also define the method.
	this is only applicable if both the interfaces have  the same method.

	Class has more power than interface

	**while using default methods we cannot override the methods present in the object class

	**Differences between static and default methods in Java 8:

	1) Default methods can be overriden in implementing class, while static cannot.

	2) Static method belongs only to Interface class, so you can only invoke static method on Interface class, not on class implementing this Interface


2.We got lambda functions

	Java lambda expression is treated as a function, so compiler does not create .class file. It is usuall used to implement a functional Interface

	**	@FunctionalInterface -any class marked with the above annotation can have only one abstract method and it can have any number of default methods. These are mainly added to support lambda expressions
	java.lang.Runnable is a example for functional Interface

	eg: Adding Functiona Interface

				@FunctionalInterface
				public interface FunctinalLambda {

					 abstract Employee getEmployee(int employeeId);
					
					 default Employee showEmployee(int employeeId){
						return  new Employee(10, "mmmm");
					 }
				}

This is the implementation, We donot have to create a new class for the implementation instead we can

							public class RunLambda {

					public static void main(String[] args) {
						FunctinalLambda lambda = i ->  new Employee(i, "Thejas");
						
						
						lambda.getEmployee(2);
					}
				}


	**In java we have a internal foreach loop for a list , the input parameter for the internal forEach(java.util.function.Consumer), we have to pass a consumer object

	Consume is a functional Interface it has accept method

	java.util.function.Consumer was introduced in java 8

		eg List<Employee> employeeList=new ArrayList<>();

		employeeList.forEach(i -> sop(i)); //This will iterate the list



	**Anonymus Innner class- A class without any name used inside a class if we use there will not be a innclasss.class file created

	Limitations Of Lamnda Functions

	1.Variable used in lambda expression should be final or effectively final
	2. WE can only implement one method for a reference


3.Stream api

	A java stream is a component which provides functionality for processing the elements during iteration

		Stream spi are used to method chaining

To use stream we need to 
	1.Obtain a stream
	2.call zero or non tearminal operation on stream
	3.call terminal operartion  on stream

	Intermidiate Operation
	Intermidiate operations add element processing operations to the stream, but does not start the iteration of the elements.
	Intermediate operation is lazy and Terminal operations is not
	 We cannot repeat the intermidiate Operation on a stream , it will not have any compitaion error but it will throw exception.
	 we need to call the method using the new stream returned from the previous stream

	When you invoke an intermediate operation on a stream, the operation is not executed immediately. It is executed only when a terminal operation is invoked on that stream
	You can chain multiple intermediate operations and none of them will do anything until you invoke a terminal operation
	All intermediate operations return Stream (can be chained), while terminal operations don't. 

**Intermediate Operations are:

	filter(Predicate<T>)
	map(Function<T>)

Terminal operations produces a non-stream (cannot be chained) result such as primitive value, a collection or no value at all.

**Terminal Operations are:

	forEach
	forEachOrdered
	toArray


**Call by Method or Method Reference  in java 
	eg
	List<String> name=Arrays.asList("Naven","manoj","Raju");

	name.forEach(System.out :: println); // WE are not using lambda here , we are using method reference here

	the above line is called function programming , here we are passing the method inside a method and we should use class name followed by 2 double colns followed by method name.
	When passing the method the class should be a functional Interface


**Java 9
	
	The collectionFactory method, java has added new static method in list,set,map interface which will allow us to create immutable objects of these collections
	eg List.of();
		Set.of();
		Map.of();

	1.Jigsaw project-
	 Jigsaw project helps us to achieve modularity

	 rt.jar- runtime jar- It has all the classes like string,system all belong to this jar

	 WE are not using jar we r using modules which is required for a particulr project instead of using one big jar

	2.REPL- Read Evolve Print Loop- with the help of jshell- It is helpful for learing, to write sop statemtne we dont have to create a class or method we just have to use the jshell terminal.

	3.Enhancement of stream api
	4.In java9 we can have private methods defined in interface
	

**Java11

In string there is a method called repeat(3);
which will repeat 3 times

isBlank()- Cheks whether the given string is blank

In Java 11, there are various methods, such as writeString(), readString(), and isSameFile() which help us to perform several operations on file.

A static not method has been added to the Predicate interface. We can use it to negate an existing predicate, much like the negate method:

				List withoutBlanks = sampleList.stream()
		  .filter(Predicate.not(String::isBlank))
  
  Support for using the local variable syntax (var keyword) in lambda parameters was added in Java 11.

We can make use of this feature to apply modifiers to our local variables, like defining a type annotation:

		List<String> sampleList = Arrays.asList("Java", "Kotlin");
		String resultString = sampleList.stream()
		  .map((@Nonnull var x) -> x.toUpperCase())
		  .collect(Collectors.joining(", "));
		assertThat(resultString).isEqualTo("JAVA, KOTLIN");

WE can use annotations in lambda expressions 
Consumer<String> consumer=(@Depriceted var i) -> sop("this is the string");

Java 17 
Record video https://www.youtube.com/watch?v=gJ9DYC-jswo&t=174s
	we have record classes record Employee (int id,String name) {} we dont have to create a class just this one will is enough. toString, hashcode methods are by default implememted for these record classes. The record class will not have setters by default all the fields will be private final
	
**AOP-Aspect Oriented Programming
It is used to increase the modularity by cross cutting concerns, A cross cutting concern is a concern that effect the whole application
and it should be centralized in a single location eg logging,transactionmanagement etc


Steps in aspects
1. Write Aspects using @Aspect annotation while creating a class
2.In the same class create methods with @Before annotaion specifiying before which method it has to be executed

	eg 
	@Before("execution(public String com.tsoft.Employee.getName())")
	public void getMessage(){
	sop("get message")
	}
Also in spring.xml we have use a tag
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>


-----------------------------

2.Type script questions and variables
3.events and its advantage
4.routing and its advantage
5.pipes
6.current versions of spring,hibernate,angular


Array Programs

 https://javarevisited.blogspot.com/2015/06/top-20-array-interview-questions-and-answers.html

https://www.javacodegeeks.com/2013/11/spring-security-behind-the-scenes.html
Spring security behind the scenes
Mongodb questions

MultiThreading
Different scopes in sprng
@Restcontroller and @Controller implementation
Spring mvc+angular
https://examples.javacodegeeks.com/enterprise-java/spring/mvc/spring-mvc-and-angular-6-example/
