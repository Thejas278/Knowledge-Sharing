Important topics and Explanation

Java is platform independent but jdk,jre,jvm are all platform dependent.

JDK- Java developemt kit 
it is use to develop and run java application, JDK is platform dependent

JDK=JRE+developement tools

JRE- Java Runtime Envrionment 
is used in the client machine just to run- 

JRE=JVM+library classes

JVM is a virtul machine which is a interpretor and it is responsible for line by line execution.JVM converts the byte code into machine level language
 JVM is also platform dependent and provides core java functions like memory management, garbage collection, security etc.
 WE need to have different jvm for different operating system

 Members of the class-fields,methods and inner classes

 variables decalred using final keyword can only be initialized in a constructor.
 static final variables can be  initialized inside only inside a static block.

 final methods are inherited but are not overridden

 final keyword cannot be used to constructor because constructors are not inherited.

 We cannot create a final interface(eg String class)
 we cannot use abstract and static keywords together(y.... think monkey ??..think!!)

 A final class cannot be extended, we should use the final class if we do not want inheritance,
 If we want to promote composition over inheritance.

 1-No, declaring the constructor as final is not possible.We will get complitation error saying  final modifier not allowed.
 Final means you cannot override it. Since Constructor declarations are not members. They are never inherited and therefore are not subject to hiding or overriding. A parent class constructor can be invoked.

 *Garbage Collection

 Garbage collector is best example of Daemon thread as it is always running in background.
 Finalization:Just before destroying an object, Garbage Collector calls finalize() method on the object to perform cleanup activities. Once finalize() method completes, Garbage Collector destroys that object.

Stack is used to method execution, Heap is used for storing objects

Object class is the only class that does not extend any other class,every class is implicitly a subclass of Object.

Static members,private,constructors cannot be over rided and access specifiers can be changed but cannot be reduced.
Visibility in the child can be more than Parent class but cannot be less than the parent class.

String s1="thejas"
String s2="thejas"// String pool does not allow duplicated objects so only one object gets created and so s1==s2

but String s3=new String("thejas")// Object is created in heap so s1!=s3

		** 			private		     			default     			protected	public
		Class			No					Yes				No		Yes
		Nested Class		Yes					Yes				Yes		Yes
		Constructor		Yes					Yes				Yes		Yes
		Method			Yes					Yes				Yes		Yes
		Field			Yes					Yes				Yes		Yes

		A class can only be default,public and  Inner class can be private,default,protected,public

		Default is also called as package private
		Protected =Can be acessed by subclass or package private

		For overriding the return type does not matter only methodname and argumentlist matter

Constructor is a block with no return type, It has same name as the class, It is not a member of a class so its not inherited,It can only be invoked.

A subclass inherits all of the public and protected members of its parent, if the subclass is present in the same packge , then it can access the package private or default members also.
Private members cannot be accessed directly in the subclasss, they are not inherited, but if we create public getters and setters then we can access.
A nested class has access to all the private members of its enclosing class—both fields and methods. Therefore, a public or protected nested class inherited by a subclass has indirect access to all of the private members of the superclass.

static methods are inherited but not overridden, if you try to override then the static method in the parent class will be hidden
 variables declared using static final needs to be initialized

 
 Serializable is a marker interface

Casting of Objects
	MountainBike is descended from Bicycle and Object. Therefore, a MountainBike is a Bicycle and is also an Object, and it can be used wherever Bicycle or Object objects are called for.

	The reverse is not necessarily true: a Bicycle may be a MountainBike, but it isn't necessarily. Similarly, an Object may be a Bicycle or a MountainBike, but it isn't necessarily.

	Casting shows the use of an object of one type in place of another type, among the objects permitted by inheritance and implementations. For example, if we write

	Object obj = new MountainBike();
	then obj is both an Object and a MountainBike (until such time as obj is assigned another object that is not a MountainBike). This is called implicit casting.

	If, on the other hand, we write

	MountainBike myBike = obj;
	we would get a compile-time error because obj is not known to the compiler to be a MountainBike. However, we can tell the compiler that we promise to assign a MountainBike to obj by explicit casting:

	MountainBike myBike = (MountainBike)obj;
	This cast inserts a runtime check that obj is assigned a MountainBike so that the compiler can safely assume that obj is a MountainBike. If obj is not a MountainBike at runtime, an exception will be thrown.

	we can user instanceOf method to avoid the run time error
		eg
			if (obj instanceof MountainBike) {
    		MountainBike myBike = (MountainBike)obj;
		}

Custom Annotations

Need for creating custom annotations

1.For documentation purpose- Annotations will not have any functionality in this case

2.Input for a java code processor

3.Input for java library that access our annotation at runtime via java reflection

Annotations can be used in class,method,constructors,fields , parameters(See @Target(ElementType.Type) options)

		@Retention(RetentionPolicy.RUNTIME)

			RetentionPolicy.Source-It will only be present in the source code
			RetentionPolicy.Class- It will be present both in source code and class file(Compiled file)
			RetentionPolicy.Runtime- It will be availabe in runtime as well

		@Target(ElementType.Type)
		@Inherited can be used in a annotation to indicate it can be inherited
		@Documented will document the annotation in java doc

1.Annotations without any fields are called as Marker Annotations
2. If the annotation has one field then it is called Single value annotaion
#There is a  interface called Annotation, all the annotations created are subclass of this Interface

**Creating custom Annotation
1.WE need to use @interface annotation 


eg 1
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.Type)
	public @interface JsonSerializable {
	}

	Above example is a marker interface which does not have any methods,has runtime visibility, and we can apply it to types (classes)

eg @interface smartPhone{
	
	String os();
	int version();
}

we can now use @smartPhone(os="symbian",version="1") as annotation

	If the annotation does not have any value then it is called markerAnnotation
	If it has one value then single value annotation

	Using ReflectionApi we can get the value or features of the object

	eg
		 if(new GreenApple().getClass().isAnnotationPresent(Barcode.class)){
            System.out.println(new GreenApple().getClass().getAnnotation(Barcode.class));
        }

        for the above code to work the retentionpolicy should be runtime

        @Target(ElementType.TYPE)*/
		@Inherited
		@Documented
		@Retention(RetentionPolicy.RUNTIME)
		public @interface Barcode {

	    public String type() default "Main Type";

	    public int price() default 100;

		}



Cohesion refers to the level of a component which performs a single well-defined task.

In java we have call by value there is no call by reference in java because we do not have pointers
In java whatever changes we make it will be only applicable inside the method

Call by value means calling the function with parameter as value

call by reference means calling the function with paramater as reference

Association
	It is a relation between 2 independent classes establised through their objects

	Composition(has a) and Aggregation(Is a) are the 2 forms of Association.

	Aggregation is a has a relationship(Inheritance - method overriding)

		It is a unidirectional association eg department has students but vicecersa is not possible

		In Aggregation, both the entries can survive individually which means ending one entity will not effect the other entity

Composition		 is a restricted form of Aggregation in which two entities are highly dependent on each other.
				It represent parts of relationship, when one is destroyed the dependent object is also destroyed

Composition is a strong Association whereas Aggregation is a weak Association.

Inheritance

	Inheritance will make the sub classes unique by putting the commmon implementations in the super class.

	A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.

Object class in the super most class in java

	The Object class is the top of the class hierarchy. All classes are descendants from this class and inherit methods from it. Useful methods inherited from Object include toString(), equals(), clone(), and getClass().

	

Interface
	In the Java programming language, an interface is a reference type, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types

	For Non static methods if the name child method has the same name , then it will be overrided in the child class(This happens at runtime).
	For static methods,static fields,non static fields the parent method will be hidden not over ridden(this happens at compile time)

	Foo f = new Bar();
        f.instanceMethod();//child method gets executed
        f.classMethod();//parent method gets executed

while

**Comparator vs comparable

	Comparator has compare method
	comparable has compareTo method

	Comparator is used to compare more than one field
	comparable is used to  one field


	Comparator- Actual class is not effected, Implemented in the seperate class
	comparable- Actual class is effected

InnerWorking of HashMap

	HashMap uses a technique called hashing,If 2 objects are equal then they must have same hashcode
	Every object will have a hascode method which gives the hashcode of that object eg 231245 ,hashcode is a set of integer numbers.

HasMap internally has a array of Node (each Node is a linked list)
Node will have ie Node<k,v> will have

				int hashcode;
				 key;
		 		value;
				 Node<k,v> next;

the lenght of the array is by default 16(index will be 0-15)
When we try to insert a value to hashmap using put method, the hashcode of the key will be calculated and
uisng the formula
ie index=hashcode & (n-1) (& means modulus operation and n=16)
whatever index we get we will insert the keyvalue pair in that node.If there are 2 keys with the same index then the first inserted record in that node, the  "next" poniter will be pointing to this ne record.

HashMap will allow us to store a "Null" key, "Null" has a hashcode =0 so index of null key will be always 0

To get the value of the key we use the same index calculation and once we get the index we compare the hashcode value stored in the index with the hashcode of the Key value and the string key will also be compared using equals method. If both will match then the particular key will be retuned


In java 8
 If the number of duplicated index reaches more than the threshold ie TreeIFY_Threshold=8 then node switches from a linked list to a balanced tree  or binary tree to improve the performance

 Balanced tree means the heavier hashcode will be moved to the right side of the tree and the lighter one will be moved to the left.
 If the hascodes are equal then we compare the keys

 A binary search tree is a * sorted binary tree, where value of a node is greater than or equal to its * left the child and less than or equal to its right child.

 Read bst-https://www.youtube.com/watch?v=81PpYQ0AN_w


 ConcurrentHashMap vs SynchronizedHashMap-Both are used to achieve thread safe


 *SynchronizedHashMap 	maintains the lock at object level , to perform put or get we need to acquire the lock

 *ConcurrentHashMap 	mainitains the lock at bucket level
 						read operation doesn't require a lock. So any number of threads can perform a get operation on it.

						If thread1 wants to perform put operation in segment 2 and thread2 wants to perform put operation on segment 4 then it is allowed here

Difference btw HashMap and HashTable

Hashmap is not thread safe and it is not synchronized
HashTable is threads safe and it is synchnonized

HashMap is fast
HashTable is slow

HashMap can allow one null key
HashTable does not allow null key


In hasMap and hashTable the insertion hashMap is not fixed, but in linked HashMap the isertion order is fixed.


ConcurrentHashMap vs Hashtable vs Synchronized Map- All the 3 are threadSafe

		The only difference between Hashtable and Synchronized Map is that later is not a legacy and you can wrap any Map to create it's synchronized version by using Collections.synchronizedMap() method.

		

Read more: https://javarevisited.blogspot.com/2011/04/difference-between-concurrenthashmap.html#ixzz5yjFPtYkJ



HasSet vs HashMap
HashSet allows one null value HashMap allows one null key and any number of null values
HaShSet is a implemention of Set Interface, HashMap is a implemention of Map Interface
HashSet we have add , HaspMap we have put


TreeHashMap is a sorted HashMap


** TreeMap
	Some of the important points to remember about TreeMap in java are;

	Apart from implementing Map interface, Java TreeMap also implements NavigableMap and indirectly implements SortedMap interface. TreeMap also extends AbstractMap class.

	TreeMap entries are sorted in the natural ordering of its keys. It also provides a constructor to provide Comparator to be used for ordering. So if you are using any class as key, make sure it’s implementing Comparable interface for natural ordering. Check out java collections interview questions to understand the importance of these methods.

	Java TreeMap implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations.

	TreeMap is not synchronized and hence not thread-safe. For multithreaded environments, you can get a wrapped synchronized using Collections.synchronizedSortedMap method.

	TreeMap methods to get keyset and values return Iterator that are fail-fast in nature, so any concurrent modification will throw ConcurrentModificationException.
	
	TreeMap in java doesn’t allow null keys, however you can have multiple null values associated with different keys.


**Set Collection

	Set is a collection which doesnot allow duplicate values

	HashSet,LinkedHashset,TreeSet etc
	TreeSet is used for sorting

	HashSet INternally uses has map to insert the data 

	eg in the documentation
		public boolean add(E e) {
   return map.put(e, PRESENT)==null;
}


to get the value from hasSet , the iterator method will return
	public Iterator<E> iterator() {
        return map.keySet().iterator();
    }

Advantages of Data Structure
	Reusability
	Efficiency
	Abstraction

    **Stack-LIFO
     Stack is a linear list in which insertion and deletions are allowed only at one end, called top.
	Stack is a abstract datatype. I uses LIFO-Last In First Out,
	It has features like 
	push - to add a element
	pop- to delete a element
	peek-to view a element
	In stack we have only one entry point
	If we are adding more value to the fixed size stack then we get overflow error
	Underflow error is when you try to get value from a empty stack

**Queue-FIFO
	Queue is a linear list in which elements can be inserted only at one end called rear and deleted only at the other end called front.
	Queue used FIFO and it has enqueue for insertion and dequeue for deletion
	WE need to create enque,dequeue isEmpty,isFull,getSize methods with normal logic

**Linked List
	LinkedList is an implementation of both a queue and a stack

	Poll vs Pop
	Poll will return null if the list is empty and Poll is also used to remove the head element
	Pop will throw java.util.NoSuchElementException and Pop is used to remove and return the head element
	

	Other methods are 
	peek()
	peekFirst()
	peekLast()

	3 types of linkedList
	1.Single linked list
	2.doublylinkeedList
	3.CircularLinkedList

Array vs LinkedList

Array size if fixed, LinkedList size is dynamic
Array is faster for adding,deleting, Linked list is slower for these operations
Array consumes more memory, In linked List the memory can be redumped to heap



*Tree
	
	This data structure uses a concept of Node

	TopNode is root node
	lines which connect each node is edge
	Nodes which donot have any child are called Leaf Node

**Binary Tree

	Binary tree is a Tree which does not have more than 2 nodes, all the nodes can have 0,1 not more than 2 node

	Types in Binary Tree

	1.Strict Binary Tree- Either 0 or 2 nodes or childrens
	2.Full Binary Tree - Where all the childrens are on same level( they will have same right and left nodes)
	3.Complete Binary tree where the level of child nodes are l and l-1

	Depth- Distance btw Root Node
	Height-Height till last child node

	Height of the tree = height of root node




Read more: https://javarevisited.blogspot.com/2015/10/how-to-implement-binary-search-tree-in-java-example.html#ixzz5vtwsQjZh

**ArrayList vs Linked List

	ArrayList is fast for gettig the data
	LinkedList is fast for manupulating the data

	ArrayList uses dynamice resiazable array
	LinkedList uses doubly linked List



Volatile is used to solve the visiblity problem
	Whenever we use volatile for a variable , and we change the value the value will be changed in the main memory and then it will be refreshed in all the threads in which this value is used

		class Test  
		{  
		static int var=5;  
		}  
		In the above example, assume that two threads are working on the same class. Both threads run on different processors where each thread has its local copy of var. If any thread modifies its value, the change will not reflect in the original one in the main memory. It leads to data inconsistency because the other thread is not aware of the modified value.

		class Test  
		{  
		static volatile int var =5;  
		}  

		In the above example, static variables are class members that are shared among all objects. There is only one copy in the main memory. The value of a volatile variable will never be stored in the cache. All read and write will be done from and to the main memory.

For Synchronization we use Atmoic Variable
eg value++
AtomicInteger value=new AtomicINteger(1);
		value.incrementAndGet();

Design Patterns
1.Factory Design Patterns

	It is a design pattern where we are providing the interface to create a object and the subclass has to pass the type and depending on the type we are creating the object

	The Factory Method Pattern is also known as Virtual Constructor.

									class GetPlanFactory{  
			      
			   //use getPlan method to get object of type Plan   
			       public Plan getPlan(String planType){  
			            if(planType == null){  
			             return null;  
			            }  
			          if(planType.equalsIgnoreCase("DOMESTICPLAN")) {  
			                 return new DomesticPlan();  
			               }   
			           else if(planType.equalsIgnoreCase("COMMERCIALPLAN")){  
			                return new CommercialPlan();  
			            }   
			          else if(planType.equalsIgnoreCase("INSTITUTIONALPLAN")) {  
			                return new InstitutionalPlan();  
			          }  
			      return null;  
			   }  



2.Abstract Factory Pattern
		define an interface or abstract class for creating families of related (or dependent) objects but without specifying their concrete sub-classes

		example for all the banks we create a bankFctory Interface and for all the type of loan we create another Interface 

								class FactoryCreator {  
					     public static AbstractFactory getFactory(String choice){  
					      if(choice.equalsIgnoreCase("Bank")){  
					         return new BankFactory();  
					      } else if(choice.equalsIgnoreCase("Loan")){  
					         return new LoanFactory();  
					      }  
					      return null;  
					   }  
					}

3.ProtoType Design Pattern

	cloning of an existing object instead of creating new one and can also be customized as per the requirement.

		EmployeeRecord e1=new EmployeeRecord(eid,ename,edesignation,esalary,eaddress);  
          
        e1.showRecord();  
        System.out.println("\n");  
        EmployeeRecord e2=(EmployeeRecord) e1.getClone();  //IN get clone we are creating a object
        e2.showRecord();  

4.Builder Design Pattern
construct a complex object from simple objects using step-by-step approach

Create a tank Interface
create a fuel Interface

create a car interfcae which extends both tank and fuel

create a implementation nanocar extending car Interface


5.Adopter Design pattern: It is a structural design pattern where 2 unrelated interfaces can work together and the object which joins these 2 are called structural DesignPattern

6.Brdige Design Pattern
It is a structural Design Pattern where we seperate the abstraction hierarcy and implementation hieracy into 2 different layers so that chaneg in one layer will not effect the other layer

7.Facade Design patter is a patter where the complexities of the systme is hidden and the client is provided with the interface to access the system

8.Flyweight Design Pattern
In this design pattern reuseing the already ceated objects and resuing them and create new object when no match is found

9.Chain of Responsibility
A request can be handled by a chain of objects , The request is not coupled to a single object rather than a chain
eg catchblock


**Light weight process vs Heavyweight process

	Light weight process will have multiple thread  sharing the same address space.
	
	Heavy weight Process- There will be different process created to work parally and each process has its own address space.

**Difference between Thread and Process

	A Process is a OS level task or service 
	A thread runs inside a process, usually process have their own address space where as threads use shared address space


Threads
Threads is a unit of a process
They are used for parallel execution and very java program creates at least one thread [ main() thread ].

t1.join() method will make other threads to stops until the current thread completes the execution.
isAlive() is used to check whether a thread is alive or not. after join method isAlive will return false.
t1.getPriority() will give the priority of thread, the raneg of priority ranges from 1 to 10.
We can also use inbuilt constants of thread for fixing priority
	eg t1.setPriority(Thread.MIN_PRIORITY);//this is bulit in constant
t1.setName("thejas")- will set the name of thread as thejas

Thread t2=new Thread(()->{ 
			 for(int i=0;i<=5;i++){
				 System.out.println("Apple of i"+i);
			 }
		});
		t2.start();

	adding "synchronized" will make a block or method thread safe, multiple threadsa cannot acces the same resource at a time

	t1.sleep(100) vs t1.wait()

	wait() method releases the lock   -  sleep() method doesn't release the lock.
	wait is the method of Object class -  sleep is the method of Thread clas
	wait is non static Method 			- sleep is static method
	
	

	wheneever we use wait() and notify() inside the method,the method needs to be synchronized

**wait() and notify()
wait() will causes the current thread to wait untill another thread invokes notify() or notifyAll() method
notify() wakes up a single thread that is waiting to accept to use the resource (should be the first thread which used wait())
notifyAll() will wake up that are waiting to access the resource

Threads can be implemented in 2 ways. 
1. By extending Thread class
		
			public class MyThread extends Thread {
		   public void run(){  
		    System.out.println("thread is running...");  
		  } 
		   public static void main(String[] args) {
		     MyThread obj = new MyThread();
		     obj.start();
			}

			Since multiple inheritance is not possible we can use a Runnable interface to create a thread
		** 1000 millisecond is 1 second

2. By implementing Runnable Interface

			public class MyThread implements Runnable {
   public void run(){  
     System.out.println("thread is running..");  
   }  
   public static void main(String[] args) {
     Thread t = new Thread(new MyThread());
     t.start();
}


**Extends Thread class vs Implements Runnable Interface?

	Extending the Thread class will make your class unable to extend other classes, because of the single inheritance feature in  JAVA. However, this will give you a simpler code structure. If you implement Runnable, you can gain better object-oriented design and consistency and also avoid the single inheritance problems.
	If you just want to achieve basic functionality of a thread you can simply implement Runnable interface and override run() method. But if you want to do something serious with thread object as it has other methods like suspend(), resume(), ..etc which are not available in Runnable interface then you may prefer to extend the Thread class.


**Thread Life cycle in Java
	The start method creates the system resources, necessary to run the thread, schedules the thread to run, and calls the thread’s run method.

	A thread becomes “Not Runnable” when one of these events occurs:
	If sleep method is invoked.
	The thread calls the wait method.
	The thread is blocking on I/O.
	A thread dies naturally when the run method exits.

**Thread.join()-The join() method waits for a thread to die

	Why we use join() method?
	In normal circumstances we generally have more than one thread, thread scheduler schedules the threads, which does not guarantee the order of execution of threads.
For example lets have a look at the following code:
			

		Thread th1 = new Thread(new MyClass(), "th1");
      Thread th2 = new Thread(new MyClass(), "th2");
      Thread th3 = new Thread(new MyClass(), "th3");
         
      // Start first thread immediately
      th1.start();
         
      /* Start second thread(th2) once first thread(th1) 
       * is dead
       */
      try {
          th1.join();
      } catch (InterruptedException ie) {
          ie.printStackTrace();
        }
      th2.start();
         
      /* Start third thread(th3) once second thread(th2) 
       * is dead
       */
      try {
          th2.join();
      } catch (InterruptedException ie) {
           ie.printStackTrace();
        }
      th3.start();
         
      // Displaying a message once third thread is dead
      try {
          th3.join();
      } catch (InterruptedException ie) {
            ie.printStackTrace();
        }  
      System.out.println("All three threads have finished execution");
   }
}


**Why don’t we call run() method directly, why call start() method?

	If we call just run method then it will run just like a normal method and we will be not be able to take the advantage of multithreading
	If we call run method through start method a seperate new Thread gets allocated for its execution and all these threads would run simultaneously

**Can we start a thread twice in Java? 
	The answer is no, once a thread is started, it can never be started again. Doing so will throw an IllegalThreadStateException.

	method isAlive(): Determine if a thread is still running.

** How to achieve Thread Safe



1. Using the stateless Implementation

		public class StateLess{

		public static int addValue(Integer value){
		value=value+1;
		return value;
		}
		}		
IN the above example
The method neither relies on external state nor maintains state at all. Hence, it’s considered to be thread-safe and can be safely called by multiple threads at the same time.

Therefore, stateless implementations are the simplest way to achieve thread-safety.


2.Making a class Immutable-
	The easiest way to create an immutable class in Java is by declaring all the fields private and final and not providing setters

			public class MyClass {
	   			private final int number;

	   			public MyClass(int number) {
	    		this.number = number;
	   			}

	   			public int getNumber() {
				   return number;
				   }

		}

3. Synchronized Method

	public synchronized void incrementCounter() {
	    counter += 1;
	}

	We’ve created a synchronized method by prefixing the method signature with the synchronized keyword.

	Since one thread at a time can access a synchronized method, one thread will execute the incrementCounter() method, and in turn, others will do the same. No overlapping execution will occur whatsoever.

Synchronized Collection

	We can make the collections also synchronized
	Collection<Integer> syncCollection = Collections.synchronizedCollection(new ArrayList<>());
	Thread thread1 = new Thread(() -> syncCollection.addAll(Arrays.asList(1, 2, 3, 4, 5, 6)));
	Thread thread2 = new Thread(() -> syncCollection.addAll(Arrays.asList(7, 8, 9, 10, 11, 12)));
	thread1.start();
	thread2.start();

MultiThreading
 Multithreading is main done to increase the execution speed, One thread will access one core so multi threads will access multiplt cores in cpu

 2.Synchronous tasks
To take heap dum kill-3

 Thread dead lock- When the thread 1 is holding a resource lock of thread 2 and thread 2 is holding the resource lock of thread 1 then one it will be thread lock


 /*
     * This method request two locks, first String and then Integer
     */
    public void method1() {
        synchronized (String.class) {
            System.out.println("Aquired lock on String.class object");
            synchronized (Integer.class) {
                System.out.println("Aquired lock on Integer.class object");
            }
        }
    }
    /*
     * This method also requests same two lock but in exactly
     * Opposite order i.e. first Integer and then String. 
     * This creates potential deadlock, if one thread holds String lock
     * and other holds Integer lock and they wait for each other, forever.
     */
    public void method2() {
        synchronized (Integer.class) {
            System.out.println("Aquired lock on Integer.class object");
            synchronized (String.class) {
                System.out.println("Aquired lock on String.class object");
            }
        }
    }
}

solution is to maintain the order

 public void method1() {
        synchronized (Integer.class) {
            System.out.println("Aquired lock on Integer.class object");
            synchronized (String.class) {
                System.out.println("Aquired lock on String.class object");
            }
        }
    }
    public void method2() {
        synchronized (Integer.class) {
            System.out.println("Aquired lock on Integer.class object");
            synchronized (String.class) {
                System.out.println("Aquired lock on String.class object");
            }
        }
    }
}





**Inner Class

	
	1.The scope of a nested class is bounded by the scope of its enclosing class. Thus in above example, class NestedClass does not exist independently of class OuterClass.
	2.A nested class has access to the members, including private members, of the class in which it is nested. However, reverse is not true i.e. the enclosing class does not have access to the members of the nested class.
	3.A nested class is also a member of its enclosing class.
	

	For inner class the class file will be created name will be A$B.class where A is the outer class and B is the inner class


	There are 3 types 

	1.Non Static class
		To Acess the inner class variables we have to the following
	we have to create a outer class Instance and using that we have to access the inner class variables

		Outer o=new Outer();
		Outer.Inner u= o.new Inner();

		If we want to access the outer class non static variables then we dont have to create the objects of outer class

		public class InnerRun  {
		private int it=10;
		int j=20;
	
	
		public class Ulai{
		public void getUlai(){
			
		System.out.println(j+it);
		}
	}

		}


	2.Static Class
		**If we make the inner class static we dont need to create the object of the outer class,
		**Only Nested class can be static , the outer class cannot be static

		To Acess the non static variables inside a static class
		StringUnique.Inside u = new StringUnique.Inside();
		u.run();

** 	To acess the non static inner class , we have to create Object of the outer class
	To acess the  static inner class , we do not have to create object of outer class

	A static class cannot access non-static members of the Outer class. It can access only static members of Outer class.


	3.Anonymous Inner Classes

	**	Age oj1 = new Age() {
            @Override
            public void getAge() {
                System.out.print("Age is "+x);
            }
        };

	Age is a interface,
** Anonymous Objects are objects without reference
	new A().showEmployee();// This does not have a reference and hence it will not utilize the stack memory , it will use only heap

	Since anonymous objects dont have reference , they are eligible for garbage collection

**	What are inner beans

In Spring framework, whenever a bean is used for only one particular property, it’s advise to declare it as an inner bean. And the inner bean is supported both in setter injection ‘property‘ and constructor injection ‘constructor-arg‘. Like Inner classes are the classes which are defined inside the scope of another class. Similarly inner beans are the beans which are defined in the scope of another bean.

<bean id="outer_bean" class="OuterBean">
      <property name="innerbean">
           <bean  class="InnerBean"/>
      </property>
</bean>

In this case an instance of InnerBean class will be created and wired in to innerbean property of OuterBean class.We should not use Id or name for them and their default scope is prototype


---------------------------------Java Upgrades--------------------------------------------------------------------------------------------

**In java 8 

1.we can create methods in interface

	Inside interface you can define a method with a default keyword and for defining static methods we dont have to use default keyword
	eg:

	public interface employee{

	public Employee getEmployee();

	default Employee findEmployee(int employeeId){

	}
	}

	If there are 2 interfaces which hav deined a same method in them then the implementing class shoudl also define the method.
	this is only applicable if both the interfaces have  the same method.

	Class has more power than interface

	**while using default methods we cannot override the methods present in the object class

	**Differences between static and default methods in Java 8:

	1) Default methods can be overriden in implementing class, while static cannot.

	2) Static method belongs only to Interface class, so you can only invoke static method on Interface class, not on class implementing this Interface


2.We got lambda functions

	Java lambda expression is treated as a function, so compiler does not create .class file. It is usuall used to implement a functional Interface

	**	@FunctionalInterface -any class marked with the above annotation can have only one abstract method and it can have any number of default methods. These are mainly added to support lambda expressions
	java.lang.Runnable is a example for functional Interface

	eg: Adding Functiona Interface

				@FunctionalInterface
				public interface FunctinalLambda {

					 abstract Employee getEmployee(int empployeeId);
					
					 default Employee showEmployee(int empployeeId){
						return  new Employee(10, "mmmm");
					 }
				}

This is the implementation, WE donot have to create a new class for the implementation instead we can

							public class RunLambda {

					public static void main(String[] args) {
						FunctinalLambda lambda = i ->  new Employee(i, "Thejas");
						
						
						lambda.getEmployee(2);
					}
				}


	**In java we have a internal foreach loop for a list , the input parameter for the internal forEach(java.util.function.Consumer), we have to pass a consumer object

	Consume is a functional Interface it has accept method

	java.util.function.Consumer was introduced in java 8

		eg List<Employee> employeeList=new ArrayList<>();

		employeeList.forEach(i -> sop(i)); //This will iterate the list



	**Anonymus Innner class- A class without any name used inside a class if we use there will not be a innclasss.class file created

	Limitations Of Lamnda Functions

	1.we cannot change the value of local variables , because inside the lambda funtion the copy of the local variable is already stored so complier restricts us from changing the value
	2. WE can only implement one method for a reference


3.Stream api

	A java stream is a component which provides functionality for processing the elements during iteration

		Stream spi are used to method chaining

To use stream we need to 
	1.Obtain a stream
	2.call zero or non tearminal operation on stream
	3.call terminal operartion  on stream

	Intermidiate Operation
	INtermidiate operations add element processing operations to the stream, but does not start the iteration of the elements.
	 Intermediate operation is lazy and Terminal operations is not
	 WE cannot repeat the intermidiate Operation on a stream , it will not have any compitaion error but it will throw exception.
	 we need to call the method using the new stream returned from the previous stream

	When you invoke an intermediate operation on a stream, the operation is not executed immediately. It is executed only when a terminal operation is invoked on that stream
	You can chain multiple intermediate operations and none of them will do anything until you invoke a terminal operation
	All intermediate operations return Stream (can be chained), while terminal operations don't. 

**Intermediate Operations are:

	filter(Predicate<T>)
	map(Function<T>)

Terminal operations produces a non-stream (cannot be chained) result such as primitive value, a collection or no value at all.

**Terminal Operations are:

	forEach
	forEachOrdered
	toArray


**Call by Method or Method Reference  in java 
	eg
	List<String> name=Arrays.asList("Naven","manoj","Raju");

	name.forEach(System.out :: println); // WE are not using lambda here , we are using method reference here

	the above line is called function programming , here we are passing the method inside a method and we should use class name followed by 2 double colns followed by method name.
	When passing the method the class should be a functional Interface


**Java 9
	
	The collectionFactory method, java has added new static method in list,set,map interface whihc will allow us to create immutable objects of these collections
	eg List.of();
		Set.of();
		Map.of();

	1.Jigsaw project-
	 Jigsaw project helps us to achieve modularity

	 rt.jar- runtime jar- It has all the classes like string,system all belong to this jar

	 WE are not using jar we r using modules which is required for a particulr project instead of using one big jar

	2.REPL- Read Evolve Print Loop- with the help of jshell- It is helpful for learing, to write sop statemtne we dont have to create a class or method we just have to use the jshell terminal.

	3.Enhancement of stream api
	4.In java9 we can have private methods defined in interface
	

**Java11

In string there is a method called repeat(3);
which will repeat 3 times

isBlanck()- Cheks whether the given string is blank

WE can use annotations in lambda expressions 
Consumer<String> consumer=(@Depriceted var i) -> sop("this is the string");


	
**AOP-Aspect Oriented Programming
It is used to increase the modularity by cross cutting concerns, A cross cutting concern is a concern that effect the whole application
and it should be centralized in a single location eg logging,transactionmanagement etc


Steps in aspects
1. Write Aspects using @Aspect annotation while creating a class
2.In the same class create methods with @Before annotaion specifiying before which method it has to be executed

	eg 
	@Before("execution(public String com.tsoft.Employee.getName())")
	public void getMessage(){
	sop("get message")
	}
Also in spring.xml we have use a tag
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>


-----------------------------

2.Type script questions and variables
3.events and its advantage
4.routing and its advantage
5.pipes
6.current versions of spring,hibernate,angular


Array Programs

 https://javarevisited.blogspot.com/2015/06/top-20-array-interview-questions-and-answers.html

https://www.javacodegeeks.com/2013/11/spring-security-behind-the-scenes.html
Spring security behind the scenes
Mongodb questions

MultiThreading
Different scopes in sprng
@Restcontroller and @Controller implementation
Spring mvc+angular
https://examples.javacodegeeks.com/enterprise-java/spring/mvc/spring-mvc-and-angular-6-example/
