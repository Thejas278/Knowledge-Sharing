Spring Security AutoConfiguration


When we login , we send the username and password, the server will validate the username and passoword and it will send a sessionid(JSessionId). This will be set in the browser cookie and whenever we send the subsequent request ,browser will send this along with each request so that we dont have to be authenticated for each request.

	Now if any other malicious site can access our sessionId and sent request on our behalf so to avoid this we need Cross Site Request Forgery


Cross-Site Request Forgery (CSRF) in simple words
		Assume you are currently logged into your online banking at www.mybank.com

		Assume a money transfer from mybank.com will result in a request of (conceptually) the form

		http://www.mybank.com/transfer?to=<SomeAccountnumber>&amount=<SomeAmount>
		(The URL doesn't require your own account number, because the server can deduce it by your login.)

		You visit www.cute-cat-pictures.org, not knowing that it is a malicious site.

		If the owner of that site knows the form of the above request (easy!) and correctly guesses you are logged into mybank.com (requires some luck!), they could include a request like this on their page:

		http://www.mybank.com/transfer?to=123456&amount=10000
		where 123456 is the number of their Cayman Islands account, and 10000 is an amount that you previously thought you were glad to possess.

		You retrieved that www.cute-cat-pictures.org page, so your browser will make that request.

		Your bank cannot recognize the origin of this request: your web browser will send the request along with your www.mybank.com cookie and it will look perfectly legitimate. There goes your money!

		This is the world without CSRF tokens.

		Now for the better one with CSRF tokens:

		The transfer request is extended with a third argument:

		http://www.mybank.com/transfer?to=123456&amount=10000&token=31415926535897932384626433832795028841971
		That token is a huge, impossible-to-guess random number that mybank.com will include on their own web page when they serve it to you. It is different each time they serve any page to anybody.

		The attacker is not able to guess the token, is not able to convince your web browser to surrender it (if the browser works correctly...), and so the attacker will not be able to create a valid request, because requests with the wrong token (or no token) will be refused by www.mybank.com.
			It's generated by the server and shared with the client. 

		Result: You keep your 10000 monetary units.

		(Your mileage may vary.)

		EDIT from comment worth reading by SOFe:

		It would be worthy to note that script from www.cute-cat-pictures.org normally does not have access to your anti-CSRF token from www.mybank.com because of HTTP access control. This note is important for some people who unreasonably send a header Access-Control-Allow-Origin: * for every website response without knowing what it is for, just because they can't use the API from another website.

			Access-Control-Allow-Origin

		When Site A tries to fetch content from Site B, Site B can send an Access-Control-Allow-Origin response header to tell the browser that the content of this page is accessible to certain origins. (An origin is a domain, plus a scheme and port number.) By default, Site B's pages are not accessible to any other origin; using the Access-Control-Allow-Origin header opens a door for cross-origin access by specific requesting origins.

		For each resource/page that Site B wants to make accessible to Site A, Site B should serve its pages with the response header:

		Access-Control-Allow-Origin: http://siteA.com
		Modern browsers will not block cross-domain requests outright. If Site A requests a page from Site B, the browser will actually fetch the requested page on the network level and check if the response headers list Site A as a permitted requester domain. If Site B has not indicated that Site A is allowed to access this page, the browser will trigger the XMLHttpRequest's error event and deny the response data to the requesting JavaScript code.

	 
How it works
	The server generates a unique token for each user session 
	The client includes the token in requests to perform sensitive actions, like submitting a form 
	The server compares the token in the request to the token in the user session 
	If the tokens don't match, the request is rejected 

	For  CSRF to work for Spring, the application must ensure that "safe" HTTP methods are read-only. This means that requests with the HTTP GET, HEAD, OPTIONS, and TRACE methods should not change the state of the application.

When we add spring security dependency in our project, GET request's will be allowed without the csrf token but for post requests crsf token is mandatory

We need CSRF is we use cookies for Authentication and Authorization

	No cookies = No CSRF

	It really is that simple. Browsers send cookies along with all requests. CSRF attacks depend upon this behavior. If you do not use cookies, and don't rely on cookies for authentication, then there is absolutely no room for CSRF attacks, and no reason to put in CSRF protection. If you have cookies, especially if you use them for authentication, then you need CSRF protection
		
Sprig Security workflow

	The client sends a request to the application  and the container creates a FilterChain which contains the Filters and Servlet that should process the HttpServletRequest based on the path of the request URI.
	
	In a Spring MVC application the Servlet is an instance of DispatcherServlet. At most one Servlet can handle a single HttpServletRequest and HttpServletResponse. However, more than one Filter can be used to:

			a:Prevent downstream Filters or the Servlet from being invoked. In this instance the Filter will typically write the HttpServletResponse.

			b:Modify the HttpServletRequest or HttpServletResponse used by the downstream Filters and Servlet

DelegatingFilterProxy
	
	Spring provides a Filter implementation named DelegatingFilterProxy that allows bridging between the Servlet container’s lifecycle and Spring’s ApplicationContext. 
	
	The Servlet container allows registering Filters using its own standards, but it is not aware of Spring defined Beans. DelegatingFilterProxy can be registered 	via standard Servlet container mechanisms, but delegate all the work to a Spring Bean that implements Filter.
	For non spring boot application we have to add the DelegatingFilterProxy manually in the web.xml with url patter as /**.
	
	When we add the spring security dependency there are around 4-5 spring security fileters and The delegating filter proxy will delegate the request to these security filters.Among the 4-5 filters one the filter is a authorisation filter
	
FilterChainProxy
	Spring Security’s Servlet support is contained within FilterChainProxy.
	FilterChainProxy is a special Filter provided by Spring Security that allows delegating to many Filter instances through SecurityFilterChain.
	Since FilterChainProxy is a Bean, it is typically wrapped in a DelegatingFilterProxy.
	
SecurityFilterChain is used by FilterChainProxy to determine which Spring Security Filter instances should be invoked for the current request.We can have multiple SecurityFilterChains

SecurityContextHolder - The SecurityContextHolder is where Spring Security stores the details of who is authenticated.

SecurityContext - is obtained from the SecurityContextHolder and contains the Authentication of the currently authenticated user.

Authentication - Can be the input to AuthenticationManager to provide the credentials a user has provided to authenticate or the current user from the SecurityContext.

GrantedAuthority - An authority that is granted to the principal on the Authentication (i.e. roles, scopes, etc.)

AuthenticationManager - the API that defines how Spring Security’s Filters perform authentication. It acts as a bridge between Specific AuthenticationProvider and spring security filters

ProviderManager - the most common implementation of AuthenticationManager.

AuthenticationProvider - used by ProviderManager to perform a specific type of authentication.

Request Credentials with AuthenticationEntryPoint - used for requesting credentials from a client (i.e. redirecting to a log in page, sending a WWW-Authenticate response, etc.)

AbstractAuthenticationProcessingFilter - a base Filter used for authentication. This also gives a good idea of the high level flow of authentication and how pieces work together.

	
	There is a Interface AuthenticationProvider which has some implementations which do the actual Authentication, It has a method called authenticate().
	
Authenticaition Objetc is like a DTO which will have crediatial and once the crediantial is validated the same Authentication object will return the principal user info as well.

This Authentication object will be stored in the security context which will be saved in the local thread so that we can get the info about current logged in user any where.

Also there is one more spring security filter which will store the principal object in the session so that we dont have to authenticate for every request and it will take this object and it will save it for thread local for every request.

UsernamePasswordAuthenticationToken is the standard which spring mvc uses for username and pwd authentication, It has a consructor which takes username and pwd 
		try{
			authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username,password));

		}catch(BadCrediantialsException e){
		if authentication fails then it will throw the exception
		}


Spring security flow

Delegating filter proxy --> FilterChainProxy ---> SecurityFilterChain --> ...AuthenticationFilter.. ---> AutenticationManager(Imp ProviderManager) --> AUthenticationProvider --> UserName authentication --> Set the security Context

	When we add the spring security dependency, when the user sends any request, the Delegating filter proxy will delegate the request to FilterChainProxy,
	FilterChainProxy will send the request to a filter called SecurityFilterChain which can delegate the request to series of filters one of the filter is AuthenticationFilter,from here the request is sent to AutenticationManager which is a interface which has a most common used implementation called ProviderManager
	ProviderManager will find the appropriate provider implementation and then we have to Implement UserDetailsService which will give have the method load by username
	We have to extend the User class privoded by the spring
	Once the authentication is performed , we get the Authentication Object which will have the principal,
	Once the filter receives this Authentication object it will be set in the spring security context as principal 
	This Authentication object will be stored in the security context which will be saved in the local thread so that we can get the info about current logged in user any where.


	AuthenticationProvider is responsible for the authentication, each provider has a method called authenticate() which will return the principal user.
			There can be a provider for pwd auth
			there can be a provider for ldap auth
			there can be a provider for Ldap auth

		AutheticationManager helps in co-ordination of multiple authenticationProviders,It too has the autenticate method,

		UserDetailService is a service provided by spring which will take a user name and return the user info


AuthenticationFilter will create a Autentication Object using the crediaitials and send it to AutenticationManager,
AutenticationManager will find the right provider using the support methods and will send the AutenticationObject to the provider, 
provider will use the UserDetailService to give the userDetails whihc will be used by the provider for verifying the user crediantials
if the autentication is successfull then the autenticationObjetc will also ave pricipal along with the crediantials.

Autenticate filter will get the authentication Objetc along with principal and it will store it in the local thread.

There is another filter which manages the user session, It will take the Autenticate Object and will associate with the user session and save it to local thread for evry request, dats y we do not need to autenticate every request,


Read the  document for proper understanding : https://docs.spring.io/spring-security/reference/servlet/getting-started.html
		
		Spring Boot automatically:

				Enables Spring Security’s default configuration, which creates a servlet Filter as a bean named SecurityFilterChain. This bean is responsible for all the security (protecting 	the application URLs, validating submitted username and passwords, redirecting to the log in form, and so on) within your application.

				Creates a UserDetailsService bean with a username of user and a randomly generated password that is logged to the console.

				Registers the Filter with a bean named springSecurityFilterChain with the Servlet container for every request.

				Spring Boot is not configuring much, but it does a lot. A summary of the features follows:

				Require an authenticated user for any interaction with the application

				Generate a default login form for you

				Let the user with a username of user and a password that is logged to the console to authenticate with form-based authentication 
				Protects the password storage with BCrypt

				Lets the user log out

				CSRF attack prevention

				Session Fixation protection

				Security Header integration

				HTTP Strict Transport Security for secure requests

				X-Content-Type-Options integration

				Cache Control (can be overridden later by your application to allow caching of your static resources)

				X-XSS-Protection integration

				X-Frame-Options integration to help prevent Clickjacking

				Integrate with the following Servlet API methods:

				HttpServletRequest#getRemoteUser()

				HttpServletRequest.html#getUserPrincipal()

				HttpServletRequest.html#isUserInRole(java.lang.String)

				HttpServletRequest.html#login(java.lang.String, java.lang.String)

				HttpServletRequest.html#logout()


				
In Webapplications we dont have to send user information for every request because we have the user information stored either in
		1.session token
		2.JWT	
Cookies
	Cookies are used to personalise the user experience , once the user logs in, the next time his preferance will be saved in the cookies
	When we make a first request to the server , the server will send a response, server will send some information in the response header which the browser will store in its cookies and for the next request it will send the same information back to the server.
	
In browser we see JSessionId
			JSESSIONID is a cookie generated by Servlet containers and used for session management in J2EE web applications for HTTP protocol. If a Web server is using a cookie for session management, it creates and sends JSESSIONID cookie to the client and then the client sends it back to the server in subsequent HTTP requests.

SessionId + COOKies vs JWT

JWT (JSON Web Token)

Stateless: The server doesn't need to keep a record of the token. 
Fast request validation: JWTs are suitable for scaling distributed applications. 
Security: JWTs use a signature to ensure security. 
Modern features: JWTs are preferred or required for many modern features, such as cross-domain functionality, serverless computing, and mobile-specific applications. 

Session-based authentication
Stateful
The server creates a session for the user and stores session data on the server-side. 
Immediate control
Session-based authentication is good for traditional applications where immediate control over sessions is important. 
Vulnerable to XSS
Session-based authentication is vulnerable to cross-site scripting (XSS) attacks. 


 XSS allows attackers to run JavaScript in a victim's browser, while CSRF tricks victims into performing actions they didn't intend. 

Cross-site scripting (XSS)
	An attacker injects malicious code into a website, such as HTML or JavaScript 
	When a victim visits the infected page, the code runs in their browser 
	XSS can be stored in a website's database, embedded in a URL, or manipulated in the document object model (DOM) 
	XSS can affect many systems at once and impact databases 

Cross-site request forgery (CSRF)
	An attacker tricks a victim into performing an action on a website where they are already authenticated 
	Attackers often use social engineering to trick victims into clicking a link in an email or chat message 
	The attacker's goal is to perform an action on behalf of the victim without their knowledge or consent 
	

JWT-JSON Web Token It is a value token

	JWT is not used for authentication, it is furthur interaction ie to remember who the user is in the subsciquent interaction.
	JWT only comes into picture only after authorization is complete

	Once the authorization is complete,server sends the jwt token to the client and the client will send it back for next subscquent request by setting it in HTTP Header (which is a key value pair)
			key used will be Authorization and value will be Bearer:jwt token
	Server signs the jwt and sends it to the client in the header, 
	The client can hold it in cookie or local storage, It has to pass it in every request
	as per jwt standard,
		In the httpHeaders we pass jwt with key as Authorization: Bearer{jwt} and send it to server

JWT will have 3 parts


	Header.Payload.Signature

	jwt.io website will help us to decode any jwt

	server generated the signature and attaches it to the jwt and sends it,Signature requires a secret key which only a server has

	Signature=base64(Header).+base64(Payload)+.secret

	Header and payload are base64 encoded, but the signature can only be autenticated by the server which has generated it

	
JWT
		While configuring the urls for permission
		permit all should be first
		specific permission next
		anyrequest.authenticated() last

		

		https://www.youtube.com/watch?v=VVn9OG9nfH0

DrwaBacks of JWT

	1.You can logoff and end the session or session can expire but for jwt u cannot do that, you can set expire for jwt as well.
	2.Someone can use my jwt and access so we have to be careful when using it because jwt will validate if the token is valid and it is not tied to a user(we can also black list if jwt is misused)

Limitations or Disadvantages of JWT
	
	Someone can steal and use the JWT

	In session based token if someone steals our token we can log off the session , but in JWT we cannot end the session ,alternately we can add the JWT to the blacklist so that it becomes invalid or we can also set expire time for JWT 

OAuth is used for Authorisation and not for Autentication

	How OAuth works(https://www.youtube.com/watch?v=t4-416mg6iU&list=PLqq-6Pq4lTTYTEooakHchTGglSvkZAjnE&index=13)
	eg Imagine a photoupload app wants to access the photos from your google drive

	when a photoupload service makes a request to google drive,google drive will send the request to the user informing about the request the photoupload service is making, and it tells the user what and all the photoupload service is trying to access,

	Once the user allows the request ,google will send a token to the photoupload service and upload service will use this token for every request to google drive

	There are many ways to implement the OAuth

	1.Authorisation token and  AccessToken token

			The client makes a call to Authorisation server,
			Authorisation server makes a call the user to confirm about the request,
			Authorisation Server then sends a short lived Authorisation token to the client ,
			client uses this Authorisation token and requests for access token from the Authorisation server
			Authorisation Server will send back the Access token to the client
			Using this access token, the client makes a call to the google drive
			google drive will verify the access token either with itself or with the  authorisation server and then it provides the resource to the client


	2.Implicit flow

		 Everything will be same except here the authorisaction server will directly send the access token there is no Authorisation token(Flow 1 is more secured and flow 2 can be used to javascript related applications)

	3.Client Crediantial Flow

		Usually for micro services we use this where we trust the client

	OAuth means Open Authorisation, 
	Using OAuth we get Authorisation if we connect open Id then we will get  Authentication as well
	Earlier we were entering our gmail password inside any 3rd party applications but it was very risky so OAuth came into picture
	In OAuth u enter ur password into the oauth server and not to the application server which wants to access your data
	
	Risk of OAuth
	If you dont trust the app then giving access to your google account is not a good idea.
	If user deletes is facebook account then we have to again authenticate the user
	
	
	API Gateway Pattern-
		ZUUL-It is the open source api gateway provided by Netflix
		
	To implements api gateway we have to add gateway starter and starter eureka client
	In application.yml we have to list the services (id,url,predicates) to that for out different microservices this service will act as the gateway


https://www.youtube.com/watch?v=X80nJ5T7YpE
