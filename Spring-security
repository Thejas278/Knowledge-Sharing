Spring Security AutoConfiguration

		https://docs.spring.io/spring-security/reference/servlet/getting-started.html

		Read the above document for proper understanding
		
		Spring Boot automatically:

				Enables Spring Security’s default configuration, which creates a servlet Filter as a bean named springSecurityFilterChain. This bean is responsible for all the security (protecting the application URLs, validating submitted username and passwords, redirecting to the log in form, and so on) within your application.

				Creates a UserDetailsService bean with a username of user and a randomly generated password that is logged to the console.

				Registers the Filter with a bean named springSecurityFilterChain with the Servlet container for every request.

				Spring Boot is not configuring much, but it does a lot. A summary of the features follows:

				Require an authenticated user for any interaction with the application

				Generate a default login form for you

				Let the user with a username of user and a password that is logged to the console to authenticate with form-based authentication (in the preceding example, the password is 8e557245-73e2-4286-969a-ff57fe326336)

				Protects the password storage with BCrypt

				Lets the user log out

				CSRF attack prevention

				Session Fixation protection

				Security Header integration

				HTTP Strict Transport Security for secure requests

				X-Content-Type-Options integration

				Cache Control (can be overridden later by your application to allow caching of your static resources)

				X-XSS-Protection integration

				X-Frame-Options integration to help prevent Clickjacking

				Integrate with the following Servlet API methods:

				HttpServletRequest#getRemoteUser()

				HttpServletRequest.html#getUserPrincipal()

				HttpServletRequest.html#isUserInRole(java.lang.String)

				HttpServletRequest.html#login(java.lang.String, java.lang.String)

				HttpServletRequest.html#logout()

	Sprig Security workflow

			The client sends a request to the application, and the container creates a FilterChain which contains the Filters and Servlet that should process the HttpServletRequest based on the path of the request URI. In a Spring MVC application the Servlet is an instance of DispatcherServlet. At most one Servlet can handle a single HttpServletRequest and HttpServletResponse. However, more than one Filter can be used to:

				Prevent downstream Filters or the Servlet from being invoked. In this instance the Filter will typically write the HttpServletResponse.

				Modify the HttpServletRequest or HttpServletResponse used by the downstream Filters and Servlet

	DelegatingFilterProxy
	
	Spring provides a Filter implementation named DelegatingFilterProxy that allows bridging between the Servlet container’s lifecycle and Spring’s ApplicationContext. The Servlet container allows registering Filters using its own standards, but it is not aware of Spring defined Beans. DelegatingFilterProxy can be registered via standard Servlet container mechanisms, but delegate all the work to a Spring Bean that implements Filter.



In browser we see JSessionId
			JSESSIONID is a cookie generated by Servlet containers and used for session management in J2EE web applications for HTTP protocol. If a Web server is using a cookie for session management, it creates and sends JSESSIONID cookie to the client and then the client sends it back to the server in subsequent HTTP requests.

JWT will have 3 parts

Header.Payload.Signature

jwt.io will help us to decode any jwt

server generated the signature and attaches it to the jwt and sends it,Signature requires a secret key which only a server has

Signature=base64(Header).+base64(Payload)+.secret

JWT is not for authentcation, Jwt comes into picture after autorisation for subsiquent requests

In the httpHeaders we pass jwt with key as Authorization: Bearer{jwt}

JWT
		Whiel configuring the urls for permission
		permit all should be first
		specific permission next
		anyrequest.authenticated() last

		

		https://www.youtube.com/watch?v=VVn9OG9nfH0

DrwaBacks of JWT

	1.You can logoff and end the session or session can expire but for jwt u cannot do that, you can set expire for jwt as well.
	2.SOmeone can use my jwt and access so we have to be careful when using it because jwt will validate if the token is valid and it is not tied to a user


OAuth is used for Authorisation and not for Autentication

	How OAuth works(https://www.youtube.com/watch?v=t4-416mg6iU&list=PLqq-6Pq4lTTYTEooakHchTGglSvkZAjnE&index=13)
	eg Imagine a photoupload app wants to access the photos from your google drive

	when a photoupload service makes a request to google drive,google drive will send the request to the user informing about the request the photoupload service is making, and it tells the user what and all the photoupload service is trying to access,

	Once the user allows the request ,google will send a token to the photoupload service and upload service will use this token for every request to google drive

	There are many ways to implement the OAuth

	1.Authorisation token and  AccessToken token

			The client makes a call to Authorisation server,
			Authorisation server makes a call the user to confirm about the request,
			Authorisation Server then sends a short lived Authorisation token to the client ,
			client uses this Authorisation token and requests for access token from the Authorisation server
			Authorisation Server will send back the Access token to the client
			Using this access token, the client makes a call to the google drive
			google drive will verify the access token either with itself or with the  authorisation server and then it provides the resource to the client


	2.Implicit flow

		 Everything will be same except here the authorisaction server will directly send the access token there is no Authorisation token(Flow 1 is more secured and flow 2 can be used to javascript related applications)

	3.Client Crediantial Flow

		Usually for micro services we use this where we trust the client




	OAuth means Open Authorisation, 
	Using OAuth we get Authorisation if we connect open Id then we will get  Authentication as well
	Earlier we were entering our gmail password inside any 3rd party applications but it was very risky so OAuth came into picture
	In OAuth u enter ur password into the oauth server and not to the application server which wants to access your data
